<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>XR Minimal AR Test</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #ui { position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%); z-index: 10; display: flex; gap: 8px; }
    button { padding: 10px 14px; border: 0; border-radius: 999px; background: #111; color: #fff; font-weight: 600; }
    #hint { position: fixed; top: 16px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.6); color: #fff; padding: 8px 12px; border-radius: 8px; z-index: 10; }
    #build { position: fixed; top: 16px; right: 16px; background: rgba(0,0,0,0.7); color: #fff; padding: 6px 10px; border-radius: 999px; font-size: 12px; z-index: 10; }
    canvas { background: transparent !important; }
  </style>
</head>
<body>
  <div id="overlay" style="position:fixed; inset:0; z-index: 20; pointer-events:auto;">
    <div id="hint">Tap Start AR, then Place.</div>
    <div id="build">xr-min build 3</div>
    <div id="ui">
      <button id="start">Start AR</button>
      <button id="place" disabled>Place</button>
      <button id="exit" disabled>Exit</button>
      <button id="logs">Download logs</button>
    </div>
  </div>

  <script>
    // simple log buffer
    (function(){
      window.__logBuffer = [];
      const orig = console.log.bind(console);
      console.log = function(){ try { window.__logBuffer.push(new Date().toISOString()+" "+Array.from(arguments).map(x=>typeof x==='object'?JSON.stringify(x):String(x)).join(' ')); } catch(_){}; orig.apply(console, arguments); };
    })();
  </script>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/loaders/GLTFLoader.js"></script>

  <script>
  (async function(){
    const url = new URL(location.href);
    const autoPlace = url.searchParams.get('autoPlace') === '1';
    const opaque = url.searchParams.get('opaque') === '1';
    const big = url.searchParams.get('big') === '1';
    const forceCube = url.searchParams.get('cube') === '1';
    const basicMat = url.searchParams.get('basic') === '1';
    const modelUrl = url.searchParams.get('model') || './models/7579_3K_V2.glb';

    const hint = document.getElementById('hint');
    const startBtn = document.getElementById('start');
    const placeBtn = document.getElementById('place');
    const exitBtn = document.getElementById('exit');
    const logsBtn = document.getElementById('logs');

    const overlay = document.getElementById('overlay');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera();
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: !opaque });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    if (opaque) {
      renderer.setClearColor(0x000000, 1);
    } else {
      renderer.setClearColor(0x000000, 0);
    }

    // Simple reticle
    const reticleGeo = new THREE.RingGeometry(0.08, 0.1, 32).rotateX(-Math.PI/2);
    const reticleMat = new THREE.MeshBasicMaterial({ color: 0x00ffcc });
    const reticle = new THREE.Mesh(reticleGeo, reticleMat);
    reticle.visible = false;
    reticle.renderOrder = 9999; reticleMat.depthTest = false; reticleMat.depthWrite = false;
    scene.add(reticle);

    // Lights for GLB
    const amb = new THREE.AmbientLight(0xffffff, 1.0); scene.add(amb);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8); dirLight.position.set(0, 1, 0); scene.add(dirLight);

    // Cube fallback
    const s = big ? 0.8 : 0.4;
    const cube = new THREE.Mesh(
      new THREE.BoxGeometry(s, s, s),
      new THREE.MeshBasicMaterial({ color: 0xff00ff })
    );
    cube.visible = false; cube.renderOrder = 9999; cube.material.depthTest = false; cube.material.depthWrite = false;
    scene.add(cube);

    // Load GLB model by default
    let model = null; let modelLoaded = false;
    try {
      const loader = new THREE.GLTFLoader();
      loader.load(modelUrl, (gltf) => {
        model = gltf.scene || (gltf.scenes && gltf.scenes[0]);
        if (!model) { console.log('[Model] GLB had no scene, fallback cube'); return; }
        if (basicMat) {
          model.traverse((child) => {
            if (child.isMesh && child.material) {
              const map = child.material.map || null;
              child.material = new THREE.MeshBasicMaterial({ color: 0xffffff, map });
            }
          });
        }
        model.visible = false;
        model.renderOrder = 9999;
        model.traverse((child)=>{ if (child.material){ child.material.depthTest=false; child.material.depthWrite=false; child.material.transparent=false; child.material.needsUpdate=true; } });
        scene.add(model);
        modelLoaded = true;
        console.log('[Model] GLB loaded', modelUrl);
      }, undefined, (err) => { console.log('[Model] load error', String(err)); });
    } catch (e) { console.log('[Model] loader init failed', e); }

    let xrSession = null; let refSpace = null; let viewerSpace = null; let hitSource = null; let autoPlaced = false;

    async function startAR(){
      if (!navigator.xr) { alert('WebXR not supported'); return; }
      const supported = await navigator.xr.isSessionSupported('immersive-ar');
      if (!supported) { alert('immersive-ar not supported'); return; }
      const sessionInit = { requiredFeatures: ['hit-test', 'local-floor'], optionalFeatures: ['dom-overlay'], domOverlay: { root: overlay } };
      console.log('[XR] sessionInit', sessionInit);
      const session = await navigator.xr.requestSession('immersive-ar', sessionInit);
      xrSession = session; renderer.xr.setSession(session);
      exitBtn.disabled = false; startBtn.textContent = 'AR Running';
      hint.textContent = 'Move to find surface';
      session.addEventListener('end', ()=>{ startBtn.textContent='Start AR'; placeBtn.disabled=true; exitBtn.disabled=true; reticle.visible=false; cube.visible=false; });

      refSpace = await session.requestReferenceSpace('local-floor');
      viewerSpace = await session.requestReferenceSpace('viewer');
      hitSource = await session.requestHitTestSource({ space: viewerSpace });
      placeBtn.disabled = false;
      autoPlaced = false;
      if (autoPlace) {
        // Fallback auto-place using camera after 1.5s if no hit yet
        setTimeout(()=>{ try { if (!autoPlaced && renderer.xr.isPresenting) { place(); autoPlaced = true; console.log('[AutoPlace] camera fallback'); } } catch(_){} }, 1500);
      }
    }

    function place(){
      const target = (!forceCube && modelLoaded && model) ? model : cube;
      if (reticle.visible) {
        target.position.copy(reticle.position);
        target.quaternion.copy(reticle.quaternion);
      } else {
        const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
        target.position.copy(camera.position).add(dir.multiplyScalar(1));
        target.quaternion.copy(camera.quaternion);
      }
      target.position.y += 0.05;
      target.visible = true;
      if (target === model) {
        try {
          const bbox = new THREE.Box3().setFromObject(model);
          const size = new THREE.Vector3(); bbox.getSize(size);
          const maxDim = Math.max(size.x, size.y, size.z) || 1;
          const factor = Math.min(Math.max(0.05, 0.6 / maxDim), 5);
          model.scale.setScalar(factor);
          console.log('[Place] model scale factor', factor);
        } catch(_) {}
      }
      console.log('[Place] placed at', target.position);
    }

    function onXRFrame(t, frame){
      const session = frame.session; const pose = frame.getViewerPose(refSpace);
      if (hitSource && refSpace) {
        const results = frame.getHitTestResults(hitSource);
        if (results && results.length) {
          const hitPose = results[0].getPose(refSpace);
          reticle.visible = true; reticle.position.set(hitPose.transform.position.x, hitPose.transform.position.y, hitPose.transform.position.z);
          reticle.quaternion.set(hitPose.transform.orientation.x, hitPose.transform.orientation.y, hitPose.transform.orientation.z, hitPose.transform.orientation.w);
          if (autoPlace && !autoPlaced) { try { place(); autoPlaced = true; console.log('[AutoPlace] via reticle'); } catch(_){} }
        } else {
          reticle.visible = false;
        }
      }
      renderer.render(scene, camera);
    }

    renderer.setAnimationLoop(onXRFrame);

    startBtn.onclick = startAR;
    placeBtn.onclick = place;
    exitBtn.onclick = () => { try { const s = renderer.xr.getSession(); if (s) s.end(); } catch(_) {} };
    logsBtn.onclick = () => { const blob = new Blob([(window.__logBuffer||[]).join('\n')], {type:'text/plain'}); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'xr-min-logs.txt'; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),1000); };

    if (autoPlace) {
      document.addEventListener('click', () => { if (renderer.xr.isPresenting) { place(); } }, { once: true });
    }

    console.log('[Init] XR minimal ready');
  })();
  </script>
</body>
</html>


