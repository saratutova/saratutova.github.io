<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>XR Minimal AR Test</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #ui { position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%); z-index: 10; display: flex; gap: 8px; }
    button { padding: 10px 14px; border: 0; border-radius: 999px; background: #111; color: #fff; font-weight: 600; }
    #hint { position: fixed; top: 16px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.6); color: #fff; padding: 8px 12px; border-radius: 8px; z-index: 10; }
    #build { position: fixed; top: 16px; right: 16px; background: rgba(0,0,0,0.7); color: #fff; padding: 6px 10px; border-radius: 999px; font-size: 12px; z-index: 10; }
    canvas { background: transparent !important; }
  </style>
</head>
<body>
  <div id="overlay" style="position:fixed; inset:0; z-index: 20; pointer-events:auto;">
    <div id="hint">Tap Start AR, then Place.</div>
    <div id="build">xr-min build 35</div>
    <div id="ui">
      <button id="start">Start AR</button>
      <button id="place" disabled>Place</button>
      <button id="exit" disabled>Exit</button>
      <button id="logs">Download logs</button>
    </div>
  </div>

  <script>
    // simple log buffer
    (function(){
      window.__logBuffer = [];
      const orig = console.log.bind(console);
      console.log = function(){ try { window.__logBuffer.push(new Date().toISOString()+" "+Array.from(arguments).map(x=>typeof x==='object'?JSON.stringify(x):String(x)).join(' ')); } catch(_){}; orig.apply(console, arguments); };
    })();
  </script>

  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
  <script>
    // A-Frame is only loaded if we need the fallback; do not include by default to keep page light
  </script>

  <script>
  (async function(){
    const url = new URL(location.href);
    const autoPlace = url.searchParams.get('autoPlace') === '1';
    const opaque = url.searchParams.get('opaque') === '1';
    const big = url.searchParams.get('big') === '1';
    const forceCube = url.searchParams.get('cube') === '1';
    const basicMat = url.searchParams.get('basic') === '1';
    // Unit and scaling controls
    const unitsParam = (url.searchParams.get('units') || url.searchParams.get('u') || '').toLowerCase();
    const unitScaleParam = parseFloat(url.searchParams.get('unitScale') || url.searchParams.get('us') || 'NaN');
    const unitScale = Number.isFinite(unitScaleParam) ? unitScaleParam :
      (unitsParam === 'cm' ? 0.01 : unitsParam === 'mm' ? 0.001 : unitsParam === 'in' ? 0.0254 : unitsParam === 'ft' ? 0.3048 : 1);
         const targetMaxDimMeters = parseFloat(url.searchParams.get('target') || url.searchParams.get('length') || url.searchParams.get('max') || 'NaN');
     const modelUrl = url.searchParams.get('model') || './models/7579_3K_V4.glb';
     const useV1 = url.searchParams.get('v1') === '1';
     const resolvedModel = useV1 ? './models/7579_3K_V1.glb' : modelUrl;
     
     // Removed test scale - model will be displayed at real 1:1 scale

    const hint = document.getElementById('hint');
    const startBtn = document.getElementById('start');
    const placeBtn = document.getElementById('place');
    const exitBtn = document.getElementById('exit');
    const logsBtn = document.getElementById('logs');

    const overlay = document.getElementById('overlay');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera();
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: !opaque });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);
    // Ensure overlay stays interactive above the canvas
    try { renderer.domElement.style.position = 'fixed'; renderer.domElement.style.inset = '0'; renderer.domElement.style.zIndex = '0'; } catch(_) {}

    if (opaque) {
      renderer.setClearColor(0x000000, 1);
    } else {
      renderer.setClearColor(0x000000, 0);
    }

    // Simple reticle
    const reticleGeo = new THREE.RingGeometry(0.08, 0.1, 32).rotateX(-Math.PI/2);
    const reticleMat = new THREE.MeshBasicMaterial({ color: 0x00ffcc });
    const reticle = new THREE.Mesh(reticleGeo, reticleMat);
    reticle.visible = false;
    reticle.renderOrder = 9999; reticleMat.depthTest = false; reticleMat.depthWrite = false;
    scene.add(reticle);

    // Lights for GLB
    const amb = new THREE.AmbientLight(0xffffff, 1.0); scene.add(amb);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8); dirLight.position.set(0, 1, 0); scene.add(dirLight);

    // Cube fallback
    const s = big ? 0.8 : 0.4;
    const cube = new THREE.Mesh(
      new THREE.BoxGeometry(s, s, s),
      new THREE.MeshBasicMaterial({ color: 0xff00ff })
    );
    cube.visible = false; cube.renderOrder = 9999; cube.material.depthTest = true; cube.material.depthWrite = true;
    scene.add(cube);

    // Load GLB model by default
    let model = null; let modelLoaded = false; let modelOriginalMaxDim = null; let modelScaleApplied = false;
    let originalModelDimensions = null; // Store original dimensions to prevent scaling issues
    let originalModelClone = null; // Store a clean copy of the original model

    async function initModelLoader() {
      async function loadScript(url) {
        return new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.src = url; s.async = true; s.crossOrigin = 'anonymous';
          s.onload = resolve; s.onerror = reject; document.head.appendChild(s);
        });
      }

      async function tryAframeFallbackLoader(glbUrl) {
        try {
          if (!window.AFRAME) {
            await loadScript('https://aframe.io/releases/1.4.0/aframe.min.js');
            console.log('[Model] A-Frame loaded for fallback');
          }
          const afScene = document.createElement('a-scene');
          afScene.setAttribute('embedded', '');
          afScene.style.cssText = 'position:fixed;left:-9999px;top:-9999px;width:1px;height:1px;opacity:0;pointer-events:none;';
          const entity = document.createElement('a-entity');
          entity.setAttribute('id', 'fallbackModelEntity');
          // Use direct URL to avoid asset registry timing issues
          entity.setAttribute('gltf-model', glbUrl);
          entity.setAttribute('visible', 'false');
          afScene.appendChild(entity);
          document.body.appendChild(afScene);
          return await new Promise((resolve) => {
            let settled = false;
            const done = (ok) => { if (settled) return; settled = true; resolve(ok); };
            entity.addEventListener('model-loaded', () => {
              try {
                const src = entity.getObject3D && entity.getObject3D('mesh');
                if (!src) { console.log('[Model] A-Frame fallback: no mesh on entity'); done(false); return; }
                const clone = src.clone(true);
                model = clone;
                if (basicMat) {
                  model.traverse((child) => {
                    if (child.isMesh && child.material) {
                      const map = child.material.map || null;
                      child.material = new THREE.MeshBasicMaterial({ color: 0xffffff, map });
                    }
                  });
                }
                 model.visible = false; model.renderOrder = 9999;
                 model.traverse((child)=>{ if (child.material){ child.material.depthTest=true; child.material.depthWrite=true; child.material.needsUpdate=true; } });
                 // Don't apply scaling here - let the place() function handle it
                 // This prevents double-scaling and ensures proper centering
                 scene.add(model);
                 modelLoaded = true;
                 
                 // Store the original model dimensions and a clean copy
                 try { 
                   const bb = new THREE.Box3().setFromObject(model); 
                   const szz = new THREE.Vector3(); 
                   bb.getSize(szz); 
                   originalModelDimensions = { x: szz.x, y: szz.y, z: szz.z };
                   originalModelClone = model.clone(true); // Store a clean copy
                   console.log('[Model] GLB loaded via A-Frame fallback', glbUrl, 'final size m=', originalModelDimensions);
                   console.log('[Model] Original dimensions and clean copy stored');
                 } catch(_) { console.log('[Model] GLB loaded via A-Frame fallback', glbUrl); }
                done(true);
              } catch (err) { console.log('[Model] A-Frame fallback failed after load', err); done(false); }
            }, { once: true });
            entity.addEventListener('model-error', (e) => { console.log('[Model] A-Frame fallback model-error', e && e.detail); done(false); }, { once: true });
            // Safety timeout
            setTimeout(() => done(false), 15000);
          });
        } catch (err) {
          console.log('[Model] A-Frame fallback init failed', err);
          return false;
        }
      }

      try {
        let loader = null;
        async function tryEsm(url) {
          try {
            const mod = await import(url);
            console.log('[Model] ESM loader loaded', url);
            return mod.GLTFLoader || mod.default;
          } catch (err) {
            console.log('[Model] ESM loader failed', url, (err && (err.message || String(err))));
            return null;
          }
        }
        async function tryUmd(url) {
          return new Promise((resolve) => {
            const script = document.createElement('script');
            script.src = url;
            script.async = true;
            script.crossOrigin = 'anonymous';
            script.onload = () => { console.log('[Model] UMD loader loaded', url); resolve(true); };
            script.onerror = () => { console.log('[Model] UMD loader failed', url); resolve(false); };
            document.head.appendChild(script);
            setTimeout(() => resolve(false), 12000);
          });
        }
        const esmUrls = [
          'https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/loaders/GLTFLoader.js',
          'https://unpkg.com/three@0.150.1/examples/jsm/loaders/GLTFLoader.js'
        ];
        const umdUrls = [
          'https://cdn.jsdelivr.net/npm/three@0.150.1/examples/js/loaders/GLTFLoader.js',
          'https://unpkg.com/three@0.150.1/examples/js/loaders/GLTFLoader.js',
          'https://cdnjs.cloudflare.com/ajax/libs/three.js/r150/examples/js/loaders/GLTFLoader.min.js'
        ];
        for (const url of esmUrls) {
          const GLTFLoaderCtor = await tryEsm(url);
          if (GLTFLoaderCtor) { loader = new GLTFLoaderCtor(); break; }
        }
        if (!loader) {
          if (!THREE.GLTFLoader) {
            for (const url of umdUrls) {
              const ok = await tryUmd(url);
              if (ok && THREE.GLTFLoader) break;
            }
          }
          if (THREE.GLTFLoader) loader = new THREE.GLTFLoader();
        }
        if (!loader) throw new Error('GLTFLoader could not be initialized from any CDN');
        loader.load(resolvedModel, (gltf) => {
          model = gltf.scene || (gltf.scenes && gltf.scenes[0]);
          if (!model) { console.log('[Model] GLB had no scene, fallback cube'); return; }
          if (basicMat) {
            model.traverse((child) => {
              if (child.isMesh && child.material) {
                const map = child.material.map || null;
                child.material = new THREE.MeshBasicMaterial({ color: 0xffffff, map });
              }
            });
          }
          model.visible = false;
          model.renderOrder = 9999;
          model.traverse((child)=>{ if (child.material){ child.material.depthTest=true; child.material.depthWrite=true; child.material.needsUpdate=true; } });
          // Don't apply scaling here - let the place() function handle it
          // This prevents double-scaling and ensures proper centering
          scene.add(model);
          modelLoaded = true;
          
          // Store the original model dimensions and a clean copy
          try { 
            const bb = new THREE.Box3().setFromObject(model); 
            const szz = new THREE.Vector3(); 
            bb.getSize(szz); 
            originalModelDimensions = { x: szz.x, y: szz.y, z: szz.z };
            originalModelClone = model.clone(true); // Store a clean copy
            console.log('[Model] GLB loaded', resolvedModel, 'final size m=', originalModelDimensions);
            console.log('[Model] Original dimensions and clean copy stored');
          } catch(_) { console.log('[Model] GLB loaded ' + resolvedModel); }
        }, undefined, async (err) => {
          console.log('[Model] load error ' + String(err));
          try { if (!modelLoaded) await tryAframeFallbackLoader(resolvedModel); } catch(_) {}
        });
      } catch (e) {
        console.log('[Model] loader init failed ' + (e && (e.message || String(e))));
        try { if (!modelLoaded) await tryAframeFallbackLoader(resolvedModel); } catch(_) {}
      }
    }
    // Kick model loading in the background so UI is responsive immediately
    try { initModelLoader(); } catch(_) {}

    let xrSession = null; let refSpace = null; let viewerSpace = null; let hitSource = null; let autoPlaced = false;

    async function startAR(){
      if (!navigator.xr) { alert('WebXR not supported'); return; }
      const supported = await navigator.xr.isSessionSupported('immersive-ar');
      if (!supported) { alert('immersive-ar not supported'); return; }
      const sessionInit = { requiredFeatures: ['hit-test', 'local-floor'], optionalFeatures: ['dom-overlay'], domOverlay: { root: overlay } };
      console.log('[XR] sessionInit', sessionInit);
      const session = await navigator.xr.requestSession('immersive-ar', sessionInit);
      xrSession = session; renderer.xr.setSession(session);
      exitBtn.disabled = false; startBtn.textContent = 'AR Running';
      hint.textContent = 'Move to find surface';
      session.addEventListener('end', ()=>{ startBtn.textContent='Start AR'; placeBtn.disabled=true; exitBtn.disabled=true; reticle.visible=false; cube.visible=false; });

      refSpace = await session.requestReferenceSpace('local-floor');
      viewerSpace = await session.requestReferenceSpace('viewer');
      hitSource = await session.requestHitTestSource({ space: viewerSpace });
      placeBtn.disabled = false;
      autoPlaced = false;
      if (autoPlace) {
        // Fallback auto-place using camera after 1.5s if no hit yet
        setTimeout(()=>{ try { if (!autoPlaced && renderer.xr.isPresenting) { place(); autoPlaced = true; console.log('[AutoPlace] camera fallback'); } } catch(_){} }, 1500);
      }
    }

    function place(){
      const target = (!forceCube && modelLoaded && model) ? model : cube;
      
                          // Apply scaling every time to ensure proper sizing
        if (target === model) {
          // Reset scale and apply proper scaling
          target.scale.setScalar(1);
          console.log('[Place] reset scale to 1');
          
          // FORCE the model to be at REAL 1:1 scale
          try {
            if (originalModelDimensions) {
              // Use real airplane scale - should be 13.53m tall (1:1 scale)
              const expectedHeight = 13.53; // Real airplane height in meters
              const scaleFactor = expectedHeight / originalModelDimensions.y;
              
              if (Number.isFinite(scaleFactor) && scaleFactor > 0) {
                target.scale.setScalar(scaleFactor);
                console.log('[Place] REAL 1:1 SCALE - original height:', originalModelDimensions.y.toFixed(3), 'm, expected:', expectedHeight, 'm');
                console.log('[Place] Applied scale factor:', scaleFactor.toFixed(6), 'to make airplane real 1:1 size');
              }
            } else {
              console.log('[Place] No original dimensions available, using current model size');
              const bbox = new THREE.Box3().setFromObject(target);
              const size = new THREE.Vector3();
              bbox.getSize(size);
              const expectedHeight = 13.53; // Real scale
              const scaleFactor = expectedHeight / size.y;
              if (Number.isFinite(scaleFactor) && scaleFactor > 0) {
                target.scale.setScalar(scaleFactor);
                console.log('[Place] Applied real scale factor based on current size:', scaleFactor.toFixed(6));
              }
            }
          } catch(_) {
            console.log('[Place] Failed to apply scaling');
          }
          
          try { 
            if (unitScale && unitScale !== 1) { 
              target.scale.multiplyScalar(unitScale); 
              console.log('[Place] applied unitScale:', unitScale, 'new scale:', target.scale);
            } else {
              console.log('[Place] no unitScale applied, unitScale =', unitScale);
            }
          } catch(_){ }
          
          try {
            if (Number.isFinite(targetMaxDimMeters)) {
              const bboxTmp = new THREE.Box3().setFromObject(target);
              const sz = new THREE.Vector3(); 
              bboxTmp.getSize(sz);
              const maxDimNow = Math.max(sz.x, sz.y, sz.z) || 1;
              const f = targetMaxDimMeters / maxDimNow;
              if (Number.isFinite(f) && f > 0) { 
                target.scale.multiplyScalar(f); 
                console.log('[Place] applied targetMaxDim scale:', f.toFixed(6), 'target size:', targetMaxDimMeters, 'm, current max dim:', maxDimNow.toFixed(3), 'm');
                console.log('[Place] scale after targetMaxDim:', target.scale);
              }
            } else {
              console.log('[Place] no targetMaxDimMeters applied, value =', targetMaxDimMeters);
            }
          } catch(_){ }
          
          // Apply manual scale parameter if provided
          try {
            const sp = url.searchParams.get('scale');
            if (sp != null) {
              const sf = parseFloat(sp);
              if (Number.isFinite(sf) && sf > 0) { 
                target.scale.setScalar(sf); 
                console.log('[Place] applied scale param:', sf, 'new scale:', target.scale);
              }
            }
          } catch(_) {}
          
          // Log final scale and size after all scaling
          try {
            const bboxFinal = new THREE.Box3().setFromObject(target);
            const sizeFinal = new THREE.Vector3();
            bboxFinal.getSize(sizeFinal);
            console.log('[Place] FINAL scale after all scaling:', target.scale);
            console.log('[Place] FINAL model size (after scaling):', sizeFinal);
            console.log('[Place] FINAL model dimensions: X=', sizeFinal.x.toFixed(3), 'm, Y=', sizeFinal.y.toFixed(3), 'm, Z=', sizeFinal.z.toFixed(3), 'm');
            
            // Calculate what the object should look like in real life
            console.log('[Place] REAL-WORLD comparison:');
            console.log('[Place] - Your model is now', sizeFinal.x.toFixed(2), 'm wide,', sizeFinal.y.toFixed(2), 'm tall,', sizeFinal.z.toFixed(2), 'm deep');
            console.log('[Place] - A baby bed is typically ~0.7m × 0.4m × 1.4m');
            console.log('[Place] - Your model should be', (sizeFinal.x/0.7).toFixed(1), 'times wider than a baby bed');
            console.log('[Place] - Your model should be', (sizeFinal.y/0.85).toFixed(1), 'times taller than your baby bed');
          } catch(_) {}
        }
      
      if (reticle.visible) {
        target.position.copy(reticle.position);
        target.quaternion.copy(reticle.quaternion);
      } else {
        const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
        target.position.copy(camera.position).add(dir.multiplyScalar(1));
        target.quaternion.copy(camera.quaternion);
      }
      
                          // Position the object so its FRONT-BOTTOM corner is at the reticle center
        if (target === model && modelLoaded) {
          try {
            // Get current model dimensions after scaling
            const bbox = new THREE.Box3().setFromObject(target);
            const size = new THREE.Vector3();
            bbox.getSize(size);
            
            console.log('[Place] POSITIONING details:');
            console.log('[Place] - Object height:', size.y.toFixed(3), 'm');
            console.log('[Place] - Object width:', size.x.toFixed(3), 'm');
            console.log('[Place] - Object depth:', size.z.toFixed(3), 'm');
            console.log('[Place] - Reticle position (where you tapped):', reticle.position);
            
            // Position the model so its FRONT-BOTTOM corner is at the reticle center
            // We need to calculate where the front-bottom corner actually is and move the model accordingly
            
            // Get the bounding box to find the actual front, bottom, and extents
            const positionBbox = new THREE.Box3().setFromObject(target);
            const min = positionBbox.min; // Minimum extents (back, bottom, left)
            const max = positionBbox.max; // Maximum extents (front, top, right)
            
            // Calculate offsets to position front-bottom corner at reticle
            // Front = maximum Z, Bottom = minimum Y
            const offsetX = 0; // Keep X centered (no offset needed)
            const offsetY = -min.y; // Move up so bottom (min.y) is at reticle level
            const offsetZ = -max.z; // Move backward so front (max.z) is at reticle position
            
            target.position.x += offsetX;
            target.position.y += offsetY; 
            target.position.z += offsetZ;
            
            console.log('[Place] CALCULATED FRONT-BOTTOM POSITIONING:');
            console.log('[Place] - Bounding box min (back/bottom/left):', min);
            console.log('[Place] - Bounding box max (front/top/right):', max);
            console.log('[Place] - Applied X offset:', offsetX.toFixed(3), 'm (keep centered)');
            console.log('[Place] - Applied Y offset:', offsetY.toFixed(3), 'm (move up to get bottom at reticle)');
            console.log('[Place] - Applied Z offset:', offsetZ.toFixed(3), 'm (move back to get front at reticle)');
            
            console.log('[Place] - Final pivot position (front-bottom corner):', target.position);
            
            // Verify final positioning - the front-bottom corner should now be at reticle
            console.log('[Place] - Final object position:', target.position);
            console.log('[Place] - Reticle position (target):', reticle.position);
            
            // Calculate where the front-bottom corner actually is now
            const verifyBbox = new THREE.Box3().setFromObject(target);
            const frontBottomCorner = {
                x: target.position.x, // X stays centered
                y: verifyBbox.min.y,     // Bottom of the airplane
                z: verifyBbox.max.z      // Front of the airplane
            };
            
            console.log('[Place] - VERIFICATION: Front-bottom corner now at:', frontBottomCorner);
            console.log('[Place] - Should match reticle position:', reticle.position);
            console.log('[Place] - Airplane extends from front-bottom to back-top');
            console.log('[Place] - Bottom at Y:', verifyBbox.min.y.toFixed(3), 'm (should be at reticle Y)');
            console.log('[Place] - Top at Y:', verifyBbox.max.y.toFixed(3), 'm');
            console.log('[Place] - Front at Z:', verifyBbox.max.z.toFixed(3), 'm (should be at reticle Z)');
            console.log('[Place] - Back at Z:', verifyBbox.min.z.toFixed(3), 'm');
          
                       // Scale verification
            console.log('[Place] SCALE VERIFICATION:');
            console.log('[Place] - Your baby bed is ~0.85m tall');
            console.log('[Place] - This airplane model is', size.y.toFixed(2), 'm tall');
            console.log('[Place] - The airplane should be', (size.y/0.85).toFixed(1), 'times taller than your baby bed');
            console.log('[Place] - This is REAL 1:1 SCALE - airplane at real world size');
           
                       // Distance verification
            console.log('[Place] DISTANCE VERIFICATION:');
            console.log('[Place] - Reticle position (world coordinates):', reticle.position);
            console.log('[Place] - Camera position (world coordinates):', camera.position);
            const distanceToReticle = camera.position.distanceTo(reticle.position);
            console.log('[Place] - Distance from camera to reticle:', distanceToReticle.toFixed(3), 'm');
            console.log('[Place] - This is a REAL distance in meters from the AR system');
         } catch(_) {}
       } else {
         target.position.y += 0.05;
       }
      
      target.visible = true;
      console.log('[Place] *** OBJECT MADE VISIBLE *** placed at', target.position);
      console.log('[Place] *** OBJECT SCALE:', target.scale, '***');
      
      // Debug: Check if object is actually in the scene
      if (target.parent) {
        console.log('[Place] *** OBJECT IS IN SCENE ***');
      } else {
        console.log('[Place] *** ERROR: OBJECT NOT IN SCENE ***');
      }
    }

    function onXRFrame(t, frame){
      const session = frame.session; const pose = frame.getViewerPose(refSpace);
      if (hitSource && refSpace) {
        const results = frame.getHitTestResults(hitSource);
        if (results && results.length) {
          const hitPose = results[0].getPose(refSpace);
          reticle.visible = true; reticle.position.set(hitPose.transform.position.x, hitPose.transform.position.y, hitPose.transform.position.z);
          reticle.quaternion.set(hitPose.transform.orientation.x, hitPose.transform.orientation.y, hitPose.transform.orientation.z, hitPose.transform.orientation.w);
          if (autoPlace && !autoPlaced) { try { place(); autoPlaced = true; console.log('[AutoPlace] via reticle'); } catch(_){} }
        } else {
          reticle.visible = false;
        }
      }
      renderer.render(scene, camera);
    }

    renderer.setAnimationLoop(onXRFrame);

    // Bind UI early and robustly
    if (startBtn) startBtn.addEventListener('click', () => { console.log('[UI] Start AR clicked'); try { startAR(); } catch(e){ console.log('[UI] startAR failed', e); } });
    if (placeBtn) placeBtn.addEventListener('click', () => { console.log('[UI] Place clicked'); try { place(); } catch(e){ console.log('[UI] place failed', e); } });
    if (exitBtn) exitBtn.addEventListener('click', () => { console.log('[UI] Exit clicked'); try { const s = renderer.xr.getSession(); if (s) s.end(); } catch(_) {} });
    if (logsBtn) logsBtn.addEventListener('click', () => {
      try {
        const text = (window.__logBuffer||[]).join('\n');
        const blob = new Blob([text], {type:'text/plain'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'xr-min-logs.txt';
        document.body.appendChild(a); a.click(); document.body.removeChild(a);
        setTimeout(()=>URL.revokeObjectURL(url), 1000);
      } catch (e) { console.log('[UI] Download logs failed', e); }
    });

    if (autoPlace) {
      document.addEventListener('click', () => { if (renderer.xr.isPresenting) { place(); } }, { once: true });
    }

    console.log('[Init] XR minimal ready');
  })();
  </script>
</body>
</html>


