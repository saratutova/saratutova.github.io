<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>XR Minimal AR Test</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #ui { position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%); z-index: 10; display: flex; gap: 8px; }
    button { padding: 10px 14px; border: 0; border-radius: 999px; background: #111; color: #fff; font-weight: 600; transition: background-color 0.3s ease; }
    button:disabled { background: #333; color: #666; }
    #place.ready { background: #00cc44 !important; color: white !important; } /* Green when surface found */
    #exit { background: #cc3300; }
    #hint { position: fixed; top: 16px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.6); color: #fff; padding: 8px 12px; border-radius: 8px; z-index: 10; }
    #build { position: fixed; top: 16px; right: 16px; background: rgba(0,0,0,0.7); color: #fff; padding: 6px 10px; border-radius: 999px; font-size: 12px; z-index: 10; }
    canvas { background: transparent !important; }
  </style>
</head>
<body>
  <div id="overlay" style="position:fixed; inset:0; z-index: 20; pointer-events:auto;">
    <div id="hint">Tap Start AR, then Place</div>
    <div id="build">xr-min build 84 + FIXED camera position 10m from nose</div>
    <div id="ui">
      <button id="start">Start AR</button>
      <button id="place" disabled>Place</button>
      <button id="exit" disabled>Exit</button>
      <button id="logs">Download logs</button>
    </div>
  </div>

  <script>
    // simple log buffer
    (function(){
      window.__logBuffer = [];
      const orig = console.log.bind(console);
      console.log = function(){ try { window.__logBuffer.push(new Date().toISOString()+" "+Array.from(arguments).map(x=>typeof x==='object'?JSON.stringify(x):String(x)).join(' ')); } catch(_){}; orig.apply(console, arguments); };
    })();
  </script>

  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
  <script>
    // A-Frame is only loaded if we need the fallback; do not include by default to keep page light
  </script>

  <script>
  (async function(){
    const url = new URL(location.href);
    const autoPlace = url.searchParams.get('autoPlace') === '1';
    const opaque = url.searchParams.get('opaque') === '1';
    const big = url.searchParams.get('big') === '1';
    const forceCube = url.searchParams.get('cube') === '1';
    const testCube = url.searchParams.get('testCube') === '1'; // 1x1x1 meter test cube
    const basicMat = url.searchParams.get('basic') === '1';
    // Real 1:1 scale by default - experience the airplane at true real-world size
    const defaultArScale = url.searchParams.get('smallScale') === '1' ? 0.1 : 1.0;
    // Unit and scaling controls
    const unitsParam = (url.searchParams.get('units') || url.searchParams.get('u') || '').toLowerCase();
    const unitScaleParam = parseFloat(url.searchParams.get('unitScale') || url.searchParams.get('us') || 'NaN');
    const unitScale = Number.isFinite(unitScaleParam) ? unitScaleParam :
      (unitsParam === 'cm' ? 0.01 : unitsParam === 'mm' ? 0.001 : unitsParam === 'in' ? 0.0254 : unitsParam === 'ft' ? 0.3048 : 1);
    const targetMaxDimMeters = parseFloat(url.searchParams.get('target') || url.searchParams.get('length') || url.searchParams.get('max') || 'NaN');
     const modelUrl = url.searchParams.get('model') || './models/Samolot_Pozycja_000_na_srodku.glb';
    const useV1 = url.searchParams.get('v1') === '1';
    const resolvedModel = useV1 ? './models/7579_3K_V1.glb' : modelUrl;
     
     // Removed test scale - model will be displayed at real 1:1 scale

    const hint = document.getElementById('hint');
    const startBtn = document.getElementById('start');
    const placeBtn = document.getElementById('place');
    const exitBtn = document.getElementById('exit');
    const logsBtn = document.getElementById('logs');

    const overlay = document.getElementById('overlay');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera();
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: !opaque });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);
    // Ensure overlay stays interactive above the canvas
    try { renderer.domElement.style.position = 'fixed'; renderer.domElement.style.inset = '0'; renderer.domElement.style.zIndex = '0'; } catch(_) {}

    if (opaque) {
      renderer.setClearColor(0x000000, 1);
    } else {
      renderer.setClearColor(0x000000, 0);
    }

    // Reticle - normal size and visible
    const reticleGeo = new THREE.RingGeometry(0.06, 0.08, 32).rotateX(-Math.PI/2);
    const reticleMat = new THREE.MeshBasicMaterial({ 
      color: 0x00ffcc, 
      transparent: true, 
      opacity: 0.8,
      side: THREE.DoubleSide 
    });
    const reticle = new THREE.Mesh(reticleGeo, reticleMat);
    reticle.visible = false;
    reticle.renderOrder = 9999; reticleMat.depthTest = false; reticleMat.depthWrite = false;
    scene.add(reticle);

    // Lights for GLB
    const amb = new THREE.AmbientLight(0xffffff, 1.0); scene.add(amb);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8); dirLight.position.set(0, 1, 0); scene.add(dirLight);

    // Cube fallback and test cube
    const s = big ? 0.8 : 0.4;
    const cube = new THREE.Mesh(
      new THREE.BoxGeometry(s, s, s),
      new THREE.MeshBasicMaterial({ color: 0xff00ff })
    );
    cube.visible = false; cube.renderOrder = 9999; cube.material.depthTest = true; cube.material.depthWrite = true;
    scene.add(cube);

    // Test cube - exactly 1x1x1 meters for debugging positioning
    // Create multi-colored faces for easy orientation debugging
    const testCubeMaterials = [
      new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.8 }), // Right face - RED
      new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.8 }), // Left face - GREEN  
      new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0.8 }), // Top face - BLUE
      new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.8 }), // Bottom face - YELLOW
      new THREE.MeshBasicMaterial({ color: 0xff00ff, transparent: true, opacity: 0.8 }), // Front face - MAGENTA/PINK
      new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 })  // Back face - CYAN
    ];
    const testCubeMesh = new THREE.Mesh(
      new THREE.BoxGeometry(1.0, 1.0, 1.0), // Exactly 1x1x1 meters
      testCubeMaterials
    );
    testCubeMesh.renderOrder = 9999; 
    testCubeMesh.material.depthTest = true; 
    testCubeMesh.material.depthWrite = true;
    
    // Create container with pivot at front-bottom center
    // When pivot is at front-bottom center, the cube mesh needs to be offset
    const testCubeObj = new THREE.Group();
    // Offset cube so that its front-bottom center is at the group's origin (0,0,0)
    // Cube center needs to move: +0.5 up (Y), -0.5 back (Z), 0 sideways (X)
    testCubeMesh.position.set(0, 0.5, -0.5); // Move cube center relative to front-bottom pivot
    testCubeObj.add(testCubeMesh);
    testCubeObj.visible = false;
    scene.add(testCubeObj);

    // Load GLB model by default
    let model = null; let modelLoaded = false; let modelOriginalMaxDim = null; let modelScaleApplied = false;
    let originalModelDimensions = null; // Store original dimensions to prevent scaling issues
    let originalModelClone = null; // Store a clean copy of the original model
    
    // Test cube models from GLB files
    let testCube1Model = null; let testCube1Loaded = false; let testCube1Dimensions = null;
    let testCube2Model = null; let testCube2Loaded = false; let testCube2Dimensions = null;

    async function initModelLoader() {
      async function loadScript(url) {
        return new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.src = url; s.async = true; s.crossOrigin = 'anonymous';
          s.onload = resolve; s.onerror = reject; document.head.appendChild(s);
        });
      }

      async function tryAframeFallbackLoader(glbUrl) {
        try {
          if (!window.AFRAME) {
            await loadScript('https://aframe.io/releases/1.4.0/aframe.min.js');
            console.log('[Model] A-Frame loaded for fallback');
          }
          const afScene = document.createElement('a-scene');
          afScene.setAttribute('embedded', '');
          afScene.style.cssText = 'position:fixed;left:-9999px;top:-9999px;width:1px;height:1px;opacity:0;pointer-events:none;';
          const entity = document.createElement('a-entity');
          entity.setAttribute('id', 'fallbackModelEntity');
          // Use direct URL to avoid asset registry timing issues
          entity.setAttribute('gltf-model', glbUrl);
          entity.setAttribute('visible', 'false');
          afScene.appendChild(entity);
          document.body.appendChild(afScene);
          return await new Promise((resolve) => {
            let settled = false;
            const done = (ok) => { if (settled) return; settled = true; resolve(ok); };
            entity.addEventListener('model-loaded', () => {
              try {
                const src = entity.getObject3D && entity.getObject3D('mesh');
                if (!src) { console.log('[Model] A-Frame fallback: no mesh on entity'); done(false); return; }
                const clone = src.clone(true);
                model = clone;
                if (basicMat) {
                  model.traverse((child) => {
                    if (child.isMesh && child.material) {
                      const map = child.material.map || null;
                      child.material = new THREE.MeshBasicMaterial({ color: 0xffffff, map });
                    }
                  });
                }
                 // Create container with pivot at front-bottom center (same as cube approach)
                 const modelContainer = new THREE.Group();
                 
                 // Store original model directly in container first 
                 const originalModel = clone;
                 originalModel.visible = false; 
                 originalModel.renderOrder = 9999;
                 originalModel.traverse((child)=>{ if (child.material){ child.material.depthTest=true; child.material.depthWrite=true; child.material.needsUpdate=true; } });
                 
                 // Add model to container (we'll position it relative to front-bottom center later)
                 modelContainer.add(originalModel);
                 modelContainer.visible = false;
                 scene.add(modelContainer);
                 
                 // Update global reference to point to container
                 model = modelContainer;
                 modelLoaded = true;
                 
                                 // Store the original model dimensions and analyze actual geometry
                try { 
                  const bb = new THREE.Box3().setFromObject(model); 
                  const szz = new THREE.Vector3(); 
                  bb.getSize(szz); 
                  originalModelDimensions = Object.freeze({ x: szz.x, y: szz.y, z: szz.z });
                  originalModelClone = model.clone(true); // Store a clean copy
                   
                   console.log('[Model] GLB loaded via A-Frame fallback', glbUrl, 'final size m=', originalModelDimensions);
                   console.log('[Model] A-FRAME BOUNDING BOX ANALYSIS:');
                   console.log('[Model] - Bounding box min:', bb.min);
                   console.log('[Model] - Bounding box max:', bb.max);
                   console.log('[Model] - Bounding box center:', bb.getCenter(new THREE.Vector3()));
                   
                   // Analyze actual vertex data
                   let minY = Infinity;
                   let maxY = -Infinity;
                   let minZ = Infinity;
                   let maxZ = -Infinity;
                   let vertexCount = 0;
                   
                   model.traverse((child) => {
                     if (child.isMesh && child.geometry) {
                       const geometry = child.geometry;
                       const positionAttribute = geometry.attributes.position;
                       
                       if (positionAttribute) {
                         child.updateMatrixWorld();
                         const vertex = new THREE.Vector3();
                         
                         for (let i = 0; i < positionAttribute.count; i++) {
                           vertex.fromBufferAttribute(positionAttribute, i);
                           vertex.applyMatrix4(child.matrixWorld);
                           
                           minY = Math.min(minY, vertex.y);
                           maxY = Math.max(maxY, vertex.y);
                           minZ = Math.min(minZ, vertex.z);
                           maxZ = Math.max(maxZ, vertex.z);
                           vertexCount++;
                         }
                       }
                     }
                   });
                   
                   console.log('[Model] A-FRAME VERTEX ANALYSIS:');
                   console.log('[Model] - Total vertices analyzed:', vertexCount);
                   console.log('[Model] - Actual Y range (height):', minY, 'to', maxY, '=', maxY - minY, 'm');
                   console.log('[Model] - Actual Z range (depth):', minZ, 'to', maxZ, '=', maxZ - minZ, 'm');
                   console.log('[Model] - BOTTOM difference: bbox.min.y =', bb.min.y, 'vs actual minY =', minY, 'diff =', bb.min.y - minY);
                   
                   // Store real bottom for accurate ground positioning
                   window.realModelBottom = minY;
                   window.realModelTop = maxY;
                   window.realModelFront = maxZ;
                   window.realModelBack = minZ;
                   
                   console.log('[Model] Original dimensions and clean copy stored');
                 } catch(_) { console.log('[Model] GLB loaded via A-Frame fallback', glbUrl); }
                done(true);
              } catch (err) { console.log('[Model] A-Frame fallback failed after load', err); done(false); }
            }, { once: true });
            entity.addEventListener('model-error', (e) => { console.log('[Model] A-Frame fallback model-error', e && e.detail); done(false); }, { once: true });
            // Safety timeout
            setTimeout(() => done(false), 15000);
          });
        } catch (err) {
          console.log('[Model] A-Frame fallback init failed', err);
          return false;
        }
      }

      try {
        let loader = null;
        async function tryEsm(url) {
          try {
            const mod = await import(url);
            console.log('[Model] ESM loader loaded', url);
            return mod.GLTFLoader || mod.default;
          } catch (err) {
            console.log('[Model] ESM loader failed', url, (err && (err.message || String(err))));
            return null;
          }
        }
        async function tryUmd(url) {
          return new Promise((resolve) => {
            const script = document.createElement('script');
            script.src = url;
            script.async = true;
            script.crossOrigin = 'anonymous';
            script.onload = () => { console.log('[Model] UMD loader loaded', url); resolve(true); };
            script.onerror = () => { console.log('[Model] UMD loader failed', url); resolve(false); };
            document.head.appendChild(script);
            setTimeout(() => resolve(false), 12000);
          });
        }
        const esmUrls = [
          'https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/loaders/GLTFLoader.js',
          'https://unpkg.com/three@0.150.1/examples/jsm/loaders/GLTFLoader.js'
        ];
        const umdUrls = [
          'https://cdn.jsdelivr.net/npm/three@0.150.1/examples/js/loaders/GLTFLoader.js',
          'https://unpkg.com/three@0.150.1/examples/js/loaders/GLTFLoader.js',
          'https://cdnjs.cloudflare.com/ajax/libs/three.js/r150/examples/js/loaders/GLTFLoader.min.js'
        ];
        for (const url of esmUrls) {
          const GLTFLoaderCtor = await tryEsm(url);
          if (GLTFLoaderCtor) { loader = new GLTFLoaderCtor(); break; }
        }
        if (!loader) {
          if (!THREE.GLTFLoader) {
            for (const url of umdUrls) {
              const ok = await tryUmd(url);
              if (ok && THREE.GLTFLoader) break;
            }
          }
          if (THREE.GLTFLoader) loader = new THREE.GLTFLoader();
        }
        if (!loader) throw new Error('GLTFLoader could not be initialized from any CDN');
        loader.load(resolvedModel, (gltf) => {
          model = gltf.scene || (gltf.scenes && gltf.scenes[0]);
          if (!model) { console.log('[Model] GLB had no scene, fallback cube'); return; }
          
          // Minimal GLB metadata logging (verbose mode disabled for stable system)
          console.log('[Model] GLB loaded:', resolvedModel);
          if (gltf.asset && gltf.asset.generator) {
            console.log('[Model] - Generator:', gltf.asset.generator);
          }
          
          // Check for extensions with unit data
          if (gltf.parser && gltf.parser.json) {
            console.log('[Model] - JSON asset:', gltf.parser.json.asset);
            console.log('[Model] - JSON extensions:', gltf.parser.json.extensions);
            console.log('[Model] - JSON extensionsUsed:', gltf.parser.json.extensionsUsed);
            console.log('[Model] - JSON extensionsRequired:', gltf.parser.json.extensionsRequired);
          }
          
          if (basicMat) {
            model.traverse((child) => {
              if (child.isMesh && child.material) {
                const map = child.material.map || null;
                child.material = new THREE.MeshBasicMaterial({ color: 0xffffff, map });
              }
            });
          }
          // Create container with pivot at front-bottom center (same as cube approach)
          const modelContainer = new THREE.Group();
          
          // Store original model in container
          const originalModel = model;
          originalModel.visible = false;
          originalModel.renderOrder = 9999;
          originalModel.traverse((child)=>{ if (child.material){ child.material.depthTest=true; child.material.depthWrite=true; child.material.needsUpdate=true; } });
          
          // Add model to container (we'll position it relative to front-bottom center later)
          modelContainer.add(originalModel);
          modelContainer.visible = false;
          scene.add(modelContainer);
          
          // Update global reference to point to container
          model = modelContainer;
          modelLoaded = true;
          
          // Store the original model dimensions and analyze actual geometry
          try { 
            const bb = new THREE.Box3().setFromObject(model); 
            const szz = new THREE.Vector3(); 
            bb.getSize(szz); 
            originalModelDimensions = Object.freeze({ x: szz.x, y: szz.y, z: szz.z });
            originalModelClone = model.clone(true); // Store a clean copy
            
            console.log('[Model] GLB loaded', resolvedModel, 'final size m=', originalModelDimensions);
            console.log('[Model] BOUNDING BOX ANALYSIS:');
            console.log('[Model] - Bounding box min:', bb.min);
            console.log('[Model] - Bounding box max:', bb.max);
            console.log('[Model] - Bounding box center:', bb.getCenter(new THREE.Vector3()));
            
            // Analyze actual vertex data to understand real geometry
            let minY = Infinity;
            let maxY = -Infinity;
            let minZ = Infinity;
            let maxZ = -Infinity;
            let vertexCount = 0;
            
            model.traverse((child) => {
              if (child.isMesh && child.geometry) {
                const geometry = child.geometry;
                const positionAttribute = geometry.attributes.position;
                
                if (positionAttribute) {
                  // Apply world matrix to get real positions
                  child.updateMatrixWorld();
                  const vertex = new THREE.Vector3();
                  
                  for (let i = 0; i < positionAttribute.count; i++) {
                    vertex.fromBufferAttribute(positionAttribute, i);
                    vertex.applyMatrix4(child.matrixWorld);
                    
                    minY = Math.min(minY, vertex.y);
                    maxY = Math.max(maxY, vertex.y);
                    minZ = Math.min(minZ, vertex.z);
                    maxZ = Math.max(maxZ, vertex.z);
                    vertexCount++;
                  }
                }
              }
            });
            
            console.log('[Model] Vertex analysis: height=' + (maxY - minY).toFixed(3) + 'm, depth=' + (maxZ - minZ).toFixed(3) + 'm');
            
            // Store real bottom for accurate ground positioning
            window.realModelBottom = minY;
            window.realModelTop = maxY;
            window.realModelFront = maxZ;
            window.realModelBack = minZ;
            
            console.log('[Model] Original dimensions and clean copy stored');
          } catch(err) { 
            console.log('[Model] GLB loaded ' + resolvedModel, 'dimension analysis failed:', err); 
          }
        }, undefined, async (err) => {
          console.log('[Model] load error ' + String(err));
          try { if (!modelLoaded) await tryAframeFallbackLoader(resolvedModel); } catch(_) {}
        });
      } catch (e) {
        console.log('[Model] loader init failed ' + (e && (e.message || String(e))));
        try { if (!modelLoaded) await tryAframeFallbackLoader(resolvedModel); } catch(_) {}
      }
    }
    
    // A-Frame fallback loader for test cubes
    async function tryAframeFallbackLoaderForCube(cubeNumber, glbUrl) {
      try {
        async function loadScript(url) {
          return new Promise((resolve, reject) => {
            const s = document.createElement('script');
            s.src = url; s.async = true; s.crossOrigin = 'anonymous';
            s.onload = resolve; s.onerror = reject; 
            document.head.appendChild(s);
          });
        }
        
        if (!window.AFRAME) {
          await loadScript('https://aframe.io/releases/1.4.0/aframe.min.js');
          console.log(`[TestCube${cubeNumber}] A-Frame loaded for fallback`);
        }
        
        const afScene = document.createElement('a-scene');
        afScene.setAttribute('embedded', '');
        afScene.style.cssText = 'position:fixed;left:-9999px;top:-9999px;width:1px;height:1px;opacity:0;pointer-events:none;';
        const entity = document.createElement('a-entity');
        entity.setAttribute('id', `fallbackTestCube${cubeNumber}Entity`);
        entity.setAttribute('gltf-model', glbUrl);
        entity.setAttribute('visible', 'false');
        afScene.appendChild(entity);
        document.body.appendChild(afScene);
        
        return await new Promise((resolve) => {
          entity.addEventListener('model-loaded', async () => {
            try {
              if (!entity.object3D || !entity.object3D.children.length) {
                console.log(`[TestCube${cubeNumber}] A-Frame fallback: no object3D children`);
                resolve(false);
                return;
              }
              
              const clone = entity.object3D.clone(true);
              
              // A-Frame GLB loaded
              console.log(`[TestCube${cubeNumber}] A-Frame GLB loaded via fallback`);
              
              // Create container with pivot at front-bottom center (same approach as airplane)
              const cubeContainer = new THREE.Group();
              
              clone.visible = false;
              clone.renderOrder = 9999;
              clone.traverse((child) => { 
                if (child.material) { 
                  child.material.depthTest = true; 
                  child.material.depthWrite = true; 
                  child.material.needsUpdate = true; 
                } 
              });
              
              cubeContainer.add(clone);
              cubeContainer.visible = false;
              scene.add(cubeContainer);
              
              // Store dimensions and analyze geometry
              try {
                const bb = new THREE.Box3().setFromObject(cubeContainer);
                const size = new THREE.Vector3();
                bb.getSize(size);
                
                console.log(`[TestCube${cubeNumber}] A-Frame fallback: size=${size.x.toFixed(2)}×${size.y.toFixed(2)}×${size.z.toFixed(2)}m`);
                
                // Analyze actual vertex data
                let minY = Infinity, maxY = -Infinity, minZ = Infinity, maxZ = -Infinity, vertexCount = 0;
                
                cubeContainer.traverse((child) => {
                  if (child.isMesh && child.geometry) {
                    const geometry = child.geometry;
                    const positionAttribute = geometry.attributes.position;
                    
                    if (positionAttribute) {
                      child.updateMatrixWorld();
                      const vertex = new THREE.Vector3();
                      
                      for (let i = 0; i < positionAttribute.count; i++) {
                        vertex.fromBufferAttribute(positionAttribute, i);
                        vertex.applyMatrix4(child.matrixWorld);
                        
                        minY = Math.min(minY, vertex.y);
                        maxY = Math.max(maxY, vertex.y);
                        minZ = Math.min(minZ, vertex.z);
                        maxZ = Math.max(maxZ, vertex.z);
                        vertexCount++;
                      }
                    }
                  }
                });
                
                console.log(`[TestCube${cubeNumber}] A-Frame vertex analysis: h=${(maxY - minY).toFixed(3)}m, d=${(maxZ - minZ).toFixed(3)}m`);
                
                // Store references and real geometry data
                if (cubeNumber === 1) {
                  testCube1Model = cubeContainer;
                  testCube1Loaded = true;
                  testCube1Dimensions = { x: size.x, y: size.y, z: size.z };
                  window.realModelBottom1 = minY;
                  window.realModelFront1 = maxZ;
                } else if (cubeNumber === 2) {
                  testCube2Model = cubeContainer;
                  testCube2Loaded = true;
                  testCube2Dimensions = { x: size.x, y: size.y, z: size.z };
                  window.realModelBottom2 = minY;
                  window.realModelFront2 = maxZ;
                }
                
                console.log(`[TestCube${cubeNumber}] A-Frame fallback successful`);
                
              } catch(err) {
                console.log(`[TestCube${cubeNumber}] A-Frame fallback dimension analysis failed:`, err);
              }
              
              resolve(true);
            } catch (err) { 
              console.log(`[TestCube${cubeNumber}] A-Frame fallback failed after load`, err); 
              resolve(false); 
            }
          }, { once: true });
          
          entity.addEventListener('model-error', (e) => { 
            console.log(`[TestCube${cubeNumber}] A-Frame fallback model-error`, e && e.detail); 
            resolve(false); 
          }, { once: true });
          
          // Safety timeout
          setTimeout(() => { 
            console.log(`[TestCube${cubeNumber}] A-Frame fallback timeout`); 
            resolve(false); 
          }, 10000);
        });
      } catch (err) {
        console.log(`[TestCube${cubeNumber}] A-Frame fallback init failed`, err);
        return false;
      }
    }
    
    // Load test cube GLB files
    async function loadTestCube(cubeNumber, glbPath) {
      try {
        // Try GLTFLoader first, then A-Frame fallback
        let loader = null;
        
        // Try to initialize GLTFLoader (same logic as main model)
        const esmUrls = [
          'https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/loaders/GLTFLoader.js',
          'https://unpkg.com/three@0.150.1/examples/jsm/loaders/GLTFLoader.js'
        ];
        const umdUrls = [
          'https://cdn.jsdelivr.net/npm/three@0.150.1/examples/js/loaders/GLTFLoader.js',
          'https://unpkg.com/three@0.150.1/examples/js/loaders/GLTFLoader.js',
          'https://cdnjs.cloudflare.com/ajax/libs/three.js/r150/examples/js/loaders/GLTFLoader.min.js'
        ];
        
        async function tryEsm(url) {
          try {
            const module = await import(url);
            return module.GLTFLoader;
          } catch(_) { return null; }
        }
        
        async function tryUmd(url) {
          try {
            await new Promise((resolve, reject) => {
              const s = document.createElement('script');
              s.src = url; s.async = true; s.crossOrigin = 'anonymous';
              s.onload = resolve; s.onerror = reject;
              document.head.appendChild(s);
            });
            return true;
          } catch(_) { return false; }
        }
        
        // Try ESM first
        for (const url of esmUrls) {
          const GLTFLoaderCtor = await tryEsm(url);
          if (GLTFLoaderCtor) { loader = new GLTFLoaderCtor(); break; }
        }
        
        // Try UMD if ESM failed
        if (!loader) {
          if (!THREE.GLTFLoader) {
            for (const url of umdUrls) {
              const ok = await tryUmd(url);
              if (ok && THREE.GLTFLoader) break;
            }
          }
          if (THREE.GLTFLoader) loader = new THREE.GLTFLoader();
        }
        
        if (!loader) {
          console.log(`[TestCube${cubeNumber}] GLTFLoader failed, trying A-Frame fallback`);
          await tryAframeFallbackLoaderForCube(cubeNumber, glbPath);
          return;
        }
        
        loader.load(glbPath, (gltf) => {
          let cubeModel = gltf.scene || (gltf.scenes && gltf.scenes[0]);
          if (!cubeModel) { 
            console.log(`[TestCube${cubeNumber}] GLB had no scene, failed to load`); 
            return; 
          }
          
          // Minimal cube GLB logging
          console.log(`[TestCube${cubeNumber}] GLB loaded:`, glbPath);
          
          // Create container with pivot at front-bottom center (same approach as airplane)
          const cubeContainer = new THREE.Group();
          
          cubeModel.visible = false;
          cubeModel.renderOrder = 9999;
          cubeModel.traverse((child) => { 
            if (child.material) { 
              child.material.depthTest = true; 
              child.material.depthWrite = true; 
              child.material.needsUpdate = true; 
            } 
          });
          
          cubeContainer.add(cubeModel);
          cubeContainer.visible = false;
          scene.add(cubeContainer);
          
          // Store dimensions and analyze geometry
          try {
            const bb = new THREE.Box3().setFromObject(cubeContainer);
            const size = new THREE.Vector3();
            bb.getSize(size);
            
            console.log(`[TestCube${cubeNumber}] GLB loaded`, glbPath, 'final size m=', size);
            console.log(`[TestCube${cubeNumber}] GLTFLoader: size=${size.x.toFixed(2)}×${size.y.toFixed(2)}×${size.z.toFixed(2)}m`);
            
            // Analyze actual vertex data
            let minY = Infinity, maxY = -Infinity, minZ = Infinity, maxZ = -Infinity, vertexCount = 0;
            
            cubeContainer.traverse((child) => {
              if (child.isMesh && child.geometry) {
                const geometry = child.geometry;
                const positionAttribute = geometry.attributes.position;
                
                if (positionAttribute) {
                  child.updateMatrixWorld();
                  const vertex = new THREE.Vector3();
                  
                  for (let i = 0; i < positionAttribute.count; i++) {
                    vertex.fromBufferAttribute(positionAttribute, i);
                    vertex.applyMatrix4(child.matrixWorld);
                    
                    minY = Math.min(minY, vertex.y);
                    maxY = Math.max(maxY, vertex.y);
                    minZ = Math.min(minZ, vertex.z);
                    maxZ = Math.max(maxZ, vertex.z);
                    vertexCount++;
                  }
                }
              }
            });
            
            console.log(`[TestCube${cubeNumber}] Vertex analysis: h=${(maxY - minY).toFixed(3)}m, d=${(maxZ - minZ).toFixed(3)}m`);
            
            // Store references and real geometry data
            if (cubeNumber === 1) {
              testCube1Model = cubeContainer;
              testCube1Loaded = true;
              testCube1Dimensions = { x: size.x, y: size.y, z: size.z };
              window.realModelBottom1 = minY;
              window.realModelFront1 = maxZ;
            } else if (cubeNumber === 2) {
              testCube2Model = cubeContainer;
              testCube2Loaded = true;
              testCube2Dimensions = { x: size.x, y: size.y, z: size.z };
              window.realModelBottom2 = minY;
              window.realModelFront2 = maxZ;
            }
            
          } catch(err) {
            console.log(`[TestCube${cubeNumber}] GLB loaded but dimension analysis failed:`, err);
          }
          
        }, undefined, async (err) => {
          console.log(`[TestCube${cubeNumber}] GLTFLoader error:`, String(err));
          console.log(`[TestCube${cubeNumber}] Trying A-Frame fallback`);
          try { await tryAframeFallbackLoaderForCube(cubeNumber, glbPath); } catch(_) {}
        });
      } catch (e) {
        console.log(`[TestCube${cubeNumber}] Loader init failed:`, e && (e.message || String(e)));
        console.log(`[TestCube${cubeNumber}] Trying A-Frame fallback`);
        try { await tryAframeFallbackLoaderForCube(cubeNumber, glbPath); } catch(_) {}
      }
    }
    
    // Kick model loading in the background so UI is responsive immediately
    try { initModelLoader(); } catch(_) {}
    
    // Load test cubes
    //try { loadTestCube(1, 'models/kostkaV2_centrum_Kolor.glb'); } catch(_) {}
    //try { loadTestCube(2, 'models/kostkaV2_Front.glb'); } catch(_) {}

    let xrSession = null; let refSpace = null; let viewerSpace = null; let hitSource = null; let autoPlaced = false;

    async function startAR(){
      if (!navigator.xr) { alert('WebXR not supported'); return; }
      const supported = await navigator.xr.isSessionSupported('immersive-ar');
      if (!supported) { alert('immersive-ar not supported'); return; }
      const sessionInit = { requiredFeatures: ['hit-test', 'local-floor'], optionalFeatures: ['dom-overlay'], domOverlay: { root: overlay } };
      console.log('[XR] sessionInit', sessionInit);
      const session = await navigator.xr.requestSession('immersive-ar', sessionInit);
      xrSession = session; renderer.xr.setSession(session);
      exitBtn.disabled = false; startBtn.textContent = 'AR Running';
      hint.textContent = 'Move to find surface';
      session.addEventListener('end', ()=>{ 
        startBtn.textContent='Start AR'; 
        placeBtn.disabled=true; 
        exitBtn.disabled=true; 
        reticle.visible=false; 
        cube.visible=false; 
        
        // Reset Place button color
        if (placeBtn) {
          placeBtn.classList.remove('ready');
        }
        
        // Clean up hit source on session end
        if (hitSource) {
          try {
            hitSource.cancel();
            console.log('[XR] Hit source cancelled on session end');
          } catch(e) {
            console.log('[XR] Hit source end cleanup failed:', e);
          }
          hitSource = null;
        }
        
        // Clean up reference spaces
        refSpace = null;
        viewerSpace = null;
        xrSession = null;
        
        // Hide ALL objects when session ends
        if (model) model.visible = false;
        if (testCubeObj) testCubeObj.visible = false;
        if (testCube1Model) testCube1Model.visible = false;
        if (testCube2Model) testCube2Model.visible = false;
        console.log('[XR] Session ended - all objects hidden'); 
      });

      refSpace = await session.requestReferenceSpace('local-floor');
      viewerSpace = await session.requestReferenceSpace('viewer');
      
      // Clean up any existing hit source before creating new one
      if (hitSource) {
        try {
          hitSource.cancel();
          console.log('[XR] Previous hit source cancelled');
        } catch(e) {
          console.log('[XR] Hit source cleanup failed:', e);
        }
        hitSource = null;
      }
      
      try {
      hitSource = await session.requestHitTestSource({ space: viewerSpace });
        console.log('[XR] Hit test source created successfully');
      } catch (err) {
        console.log('[XR] Hit test source failed:', err);
        hint.textContent = 'Hit test failed - will use camera placement';
      }
      placeBtn.disabled = false;
      autoPlaced = false;
      if (autoPlace) {
        // Fallback auto-place using camera after 1.5s if no hit yet
        setTimeout(()=>{ try { if (!autoPlaced && renderer.xr.isPresenting) { place(); autoPlaced = true; console.log('[AutoPlace] camera fallback'); } } catch(_){} }, 1500);
      }
    }

    function place(){
      try {
        // Choose target object: test cube > airplane model > fallback cube
        let target;
        if (testCube) {
          target = testCubeObj;
        } else if (!forceCube && modelLoaded && model) {
          target = model;
      } else {
          target = cube;
      }
        
        // Apply scaling to airplane model (only to the child mesh, not the container)
      if (target === model) {
          const childModel = target.children[0]; // The airplane mesh inside the container
          if (childModel) {
            // Reset child model scale and apply proper scaling
            childModel.scale.setScalar(1);
            console.log('[Place] reset child model scale to 1');
            
            // Apply base scale (force to real-world size)
            try {
              if (originalModelDimensions) {
                // Real airplane scale
                const expectedHeight = 13.53; // Real airplane height in meters
                const realScaleFactor = expectedHeight / originalModelDimensions.y;
                
                // Apply correct 1:1 real-world scaling
                const finalScaleFactor = realScaleFactor * defaultArScale;
                
                if (Number.isFinite(finalScaleFactor) && finalScaleFactor > 0) {
                  childModel.scale.setScalar(finalScaleFactor);
                  console.log('[Place] SCALING - original height:', originalModelDimensions.y.toFixed(3), 'm');
                  console.log('[Place] Real scale factor:', realScaleFactor.toFixed(6), '(to 13.53m real size)');
                  console.log('[Place] AR scale factor:', defaultArScale, '(1.0 = real world size)');
                  console.log('[Place] Final scale factor:', finalScaleFactor.toFixed(6));
                  console.log('[Place] Final airplane height:', (13.53 * defaultArScale).toFixed(3), 'm (REAL SIZE!)');
                }
              } else {
                console.log('[Place] No original dimensions available, using default scale');
                childModel.scale.setScalar(defaultArScale);
              }
            } catch(_) {
              console.log('[Place] Failed to apply scaling');
            }
            
            // Apply unit scale
            try { 
              if (unitScale && unitScale !== 1) { 
                childModel.scale.multiplyScalar(unitScale); 
                console.log('[Place] applied unitScale:', unitScale, 'new scale:', childModel.scale);
              } else {
                console.log('[Place] no unitScale applied, unitScale =', unitScale);
              }
            } catch(_){ }
            
            // Apply target max dimension scaling
            try {
              if (Number.isFinite(targetMaxDimMeters)) {
                const bboxTmp = new THREE.Box3().setFromObject(childModel);
                const sz = new THREE.Vector3(); 
                bboxTmp.getSize(sz);
                const maxDimNow = Math.max(sz.x, sz.y, sz.z) || 1;
                const f = targetMaxDimMeters / maxDimNow;
                if (Number.isFinite(f) && f > 0) { 
                  childModel.scale.multiplyScalar(f); 
                  console.log('[Place] applied targetMaxDim scale:', f.toFixed(6), 'target size:', targetMaxDimMeters, 'm, current max dim:', maxDimNow.toFixed(3), 'm');
                  console.log('[Place] scale after targetMaxDim:', childModel.scale);
                }
              } else {
                console.log('[Place] no targetMaxDimMeters applied, value =', targetMaxDimMeters);
              }
            } catch(_){ }
            
            // Apply manual scale parameter if provided
        try {
          const sp = url.searchParams.get('scale');
          if (sp != null) {
            const sf = parseFloat(sp);
                if (Number.isFinite(sf) && sf > 0) { 
                  childModel.scale.setScalar(sf); 
                  console.log('[Place] applied scale param:', sf, 'new scale:', childModel.scale);
                }
          }
        } catch(_) {}
            
            // Log final scale and calculated size (avoid setFromObject corruption)
            try {
              // CRITICAL: Calculate size from stored dimensions + scale to avoid geometry corruption
              const scaledSize = {
                x: originalModelDimensions.x * childModel.scale.x,
                y: originalModelDimensions.y * childModel.scale.y,
                z: originalModelDimensions.z * childModel.scale.z
              };
              
              console.log('[Place] FINAL scale after all scaling:', childModel.scale);
              console.log('[Place] CALCULATED model size (from stored dims):', scaledSize);
              console.log('[Place] FINAL model dimensions: X=', scaledSize.x.toFixed(3), 'm, Y=', scaledSize.y.toFixed(3), 'm, Z=', scaledSize.z.toFixed(3), 'm');
              
              // Real-world scale verification
              console.log('[Place] REAL-WORLD SCALE verification:');
              console.log('[Place] - Your airplane is now', scaledSize.x.toFixed(2), 'm wide,', scaledSize.y.toFixed(2), 'm tall,', scaledSize.z.toFixed(2), 'm deep');
              console.log('[Place] - This is REAL WORLD SIZE - same as the actual airplane!');
              console.log('[Place] - A person is ~1.7m tall - this airplane is', (scaledSize.y/1.7).toFixed(1), 'times taller than a person');
              console.log('[Place] - You should be able to walk under the wings and around the fuselage!');
              console.log('[Place] - The cockpit should be about 3-4 meters above ground level');
        } catch(_) {}
      }
        }
      
      // Check if we have a valid reticle position (not at origin)
      const hasValidReticle = reticle.visible && (reticle.position.x !== 0 || reticle.position.y !== 0 || reticle.position.z !== 0);
      
      let targetPosition = new THREE.Vector3();
      let targetQuaternion = new THREE.Quaternion();
      
      if (hasValidReticle) {
        console.log('[Place] Using valid reticle position:', reticle.position);
        targetPosition.copy(reticle.position);
        targetQuaternion.copy(reticle.quaternion);
      } else {
        console.log('[Place] No valid surface found - using camera fallback');
        const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
        targetPosition.copy(camera.position).add(dir.multiplyScalar(2)); // Place 2m in front
        targetQuaternion.copy(camera.quaternion);
        targetPosition.y = Math.max(0, camera.position.y - 1.5); // Assume floor 1.5m below camera
        console.log('[Place] Camera fallback position:', targetPosition);
      }
      
      // Position the airplane using UNIFIED POSITIONING SYSTEM
      if (target === model && modelLoaded) {
        // Calculate rotation to face camera
        const cameraDirection = new THREE.Vector3();
        camera.getWorldDirection(cameraDirection);
        
        const airplaneForwardDirection = cameraDirection.clone().multiplyScalar(-1);
        airplaneForwardDirection.y = 0; // Keep upright
        airplaneForwardDirection.normalize();
        
        const defaultForward = new THREE.Vector3(0, 0, 1);
        const rotationQuaternion = new THREE.Quaternion();
        rotationQuaternion.setFromUnitVectors(defaultForward, airplaneForwardDirection);
        
        // USE UNIFIED POSITIONING SYSTEM
        const actualBottom = window.realModelBottom || -0.0046; // From logs: airplane bottom
        const actualFront = window.realModelFront || 0.0649;    // From logs: airplane front
        
        // CRITICAL: Pass a deep copy to prevent corruption of original dimensions
        const cleanDimensions = {
          x: originalModelDimensions.x,
          y: originalModelDimensions.y,
          z: originalModelDimensions.z
        };
        
        const success = positionModel({
          target: target,
          targetPosition: targetPosition,
          rotationQuaternion: rotationQuaternion,
          modelType: 'airplane',
          originalDimensions: cleanDimensions,
          actualBottom: actualBottom,
          actualFront: actualFront,
          expectedHeight: 13.53, // Real airplane height in meters
          logPrefix: 'Place'
        });
        
        if (!success) {
          console.log('[Place] UNIFIED AIRPLANE POSITIONING FAILED');
        }
      } else if (target === testCubeObj) {
         // PROCEDURAL TEST CUBE: Use unified positioning system
         
         // Calculate rotation to face camera
         const cameraDirection = new THREE.Vector3();
         camera.getWorldDirection(cameraDirection);
         
         const cubeForwardDirection = cameraDirection.clone().multiplyScalar(-1);
         cubeForwardDirection.y = 0; // Keep cube upright
         cubeForwardDirection.normalize();
         
         const defaultForward = new THREE.Vector3(0, 0, 1);
         const rotationQuaternion = new THREE.Quaternion();
         rotationQuaternion.setFromUnitVectors(defaultForward, cubeForwardDirection);
         
         // USE UNIFIED POSITIONING SYSTEM
         const success = positionModel({
           target: target,
           targetPosition: targetPosition,
           rotationQuaternion: rotationQuaternion,
           modelType: 'proceduralCube',
           originalDimensions: { x: 1.0, y: 1.0, z: 1.0 }, // Known 1x1x1 meter cube
           actualBottom: 0,    // Procedural cube has bottom at Y=0 (from construction)
           actualFront: 0.5,   // Procedural cube front face at Z=+0.5 (from construction)
           expectedHeight: null, // No scaling needed
           logPrefix: 'PlaceTestCube'
         });
         
         if (success) {
           console.log('[PlaceTestCube] FACE COLORS: RED=Right, GREEN=Left, BLUE=Top, YELLOW=Bottom, MAGENTA=Front, CYAN=Back');
           console.log('[PlaceTestCube] The MAGENTA face should be facing you (camera)');
         } else {
           console.log('[PlaceTestCube] UNIFIED POSITIONING FAILED');
         }
         
       } else {
         // For regular cube or other objects, just place at target position
         target.position.copy(targetPosition);
         target.quaternion.copy(targetQuaternion);
         target.position.y += 0.05; // Slightly above surface
         console.log('[Place] Regular cube positioned at:', target.position);
       }
      
      target.visible = true;
      console.log('[Place] *** OBJECT MADE VISIBLE *** placed at', target.position);
      console.log('[Place] *** OBJECT SCALE:', target.scale, '***');
      
      // Debug: Check if object is actually in the scene
      if (target.parent) {
        console.log('[Place] *** OBJECT IS IN SCENE ***');
      } else {
        console.log('[Place] *** ERROR: OBJECT NOT IN SCENE ***');
      }
      
      } catch (error) {
        console.log('[Place] *** PLACEMENT FAILED ***', error);
        console.log('[Place] Error details:', error.message, error.stack);
        throw error; // Re-throw so the UI handler can catch it
      }
    }
    
    // UNIFIED MODEL POSITIONING SYSTEM
    // This function handles positioning for ANY model type consistently
    function positionModel(config) {
      try {
        const {
          target,              // THREE.Group or THREE.Object3D to position
          targetPosition,      // THREE.Vector3 where to place the pivot
          rotationQuaternion,  // THREE.Quaternion for rotation
          modelType,           // string: 'airplane', 'testCube1', 'testCube2', 'proceduralCube'
          originalDimensions,  // {x, y, z} original bounding box dimensions
          actualBottom,        // real Y minimum from vertex analysis
          actualFront,         // real Z maximum from vertex analysis (front face)
          expectedHeight,      // expected height for scaling (airplane only)
          logPrefix           // string: for logging
        } = config;
        
        console.log(`[${logPrefix}] UNIFIED POSITIONING START`);
        console.log(`[${logPrefix}] - Model type: ${modelType}`);
        console.log(`[${logPrefix}] - Target position (reticle):`, targetPosition);
        console.log(`[${logPrefix}] - Original dimensions:`, originalDimensions);
        
        // Get the child model (actual mesh inside container)
        const childModel = target.children[0];
        if (!childModel) {
          console.log(`[${logPrefix}] ERROR: No child model found`);
          return false;
        }
        
        // Special case: procedural cube is already positioned correctly
        if (modelType === 'proceduralCube') {
          console.log(`[${logPrefix}] PROCEDURAL CUBE: Already positioned correctly, skipping child positioning`);
          childModel.visible = true;
        } else {
        
        // STEP 1: SCALING (only for airplane)
        if (modelType === 'airplane' && expectedHeight) {
          childModel.scale.setScalar(1); // Reset scale
          
          const currentHeight = originalDimensions.y;
          const scaleFactor = expectedHeight / currentHeight;
          childModel.scale.setScalar(scaleFactor);
          
          console.log(`[${logPrefix}] SCALING applied:`);
          console.log(`[${logPrefix}] - Original height: ${currentHeight.toFixed(3)}m`);
          console.log(`[${logPrefix}] - Target height: ${expectedHeight.toFixed(3)}m`);
          console.log(`[${logPrefix}] - Scale factor: ${scaleFactor.toFixed(6)}`);
        } else {
          console.log(`[${logPrefix}] NO SCALING - using original GLB scale`);
        }
        
        // STEP 2: CHILD MODEL POSITIONING (front-bottom center pivot)
        // Use STORED original dimensions instead of corrupted runtime bounding box
        const currentScale = childModel.scale.x; // Current scale factor
        
        // Use stored original model dimensions (clean, never corrupted)
        // CRITICAL: Create deep copy to prevent corruption of original reference
        const cleanOriginalDims = {
          x: originalDimensions.x,
          y: originalDimensions.y, 
          z: originalDimensions.z
        };
        const size = {
          x: cleanOriginalDims.x * currentScale,
          y: cleanOriginalDims.y * currentScale,
          z: cleanOriginalDims.z * currentScale
        };
        
        // Calculate the model center based on stored vertex data
        let actualBottom, actualFront, centerX;
        
        if (modelType === 'airplane') {
          // For centered airplane: use UNSCALED distances for positioning offsets
          actualBottom = (window.realModelBottom || -0.0046); // Keep original size
          actualFront = (window.realModelFront || 0.0649);     // Keep original size  
          centerX = 0; // Airplane is centered
        } else if (modelType.includes('testCube')) {
          actualBottom = (window[`realModelBottom${modelType.slice(-1)}`] || 0) * currentScale;
          actualFront = (window[`realModelFront${modelType.slice(-1)}`] || 0.486) * currentScale;
          
          // Check if we're using old TESTBOX or new kostkaV2 files
          const isOldTestBox = originalDimensions && originalDimensions.x > 1.0; // Old TESTBOX has ~1.035m width
          if (isOldTestBox) {
            centerX = 0.136 * currentScale; // Old TESTBOX off-center
            console.log(`[${logPrefix}] Using old TESTBOX offsets`);
          } else {
            centerX = 0; // New kostkaV2 files might be properly centered
            console.log(`[${logPrefix}] Using new kostkaV2 centered`);
          }
        } else {
          // Default values
          actualBottom = 0;
          actualFront = size.z / 2;
          centerX = 0;
        }
        
        console.log(`[${logPrefix}] Stored dims: ${size.x.toFixed(2)}×${size.y.toFixed(2)}×${size.z.toFixed(2)}m (scale=${currentScale.toFixed(3)})`);
        
        // Calculate positioning offsets using STORED data (never corrupted)
        let frontOffset = -actualFront; // Front face at Z=0
        let groundOffset = -actualBottom; // Bottom at Y=0
        
        // SPECIAL FIX: Test cubes positioning
        if (modelType.includes('testCube')) {
          const isOldTestBox = originalDimensions && originalDimensions.x > 1.0;
          if (isOldTestBox) {
            // Old TESTBOX: needs orientation flip and distance adjustment
            frontOffset = actualFront - size.z - 0.2; // Flip + move 20cm back
            console.log(`[${logPrefix}] Old TESTBOX: flipped + 20cm back`);
          } else {
            // New kostkaV2: try front face directly at circle
            frontOffset = -actualFront; // Front edge at circle center
            console.log(`[${logPrefix}] New kostka: front at circle`);
          }
        }
        
        // SPECIAL FIX: Airplane positioning  
        if (modelType === 'airplane') {
          // CONFIRMED: The airplane model orientation is:
          // -Z = NOSE (front of airplane) at -0.263
          // +Z = TAIL (back of airplane) at +0.282
          // So actualFront (+0.282) is actually the TAIL!
          
          const actualNose = window.realModelBack || -0.263; // The actual nose is at -Z
          const actualTail = actualFront; // actualFront (+0.282) is the tail
          
          // To position camera in front of nose, move airplane center BACK from circle
          // This puts the nose ahead of the circle, so camera sees nose from proper distance
          const noseDistance = 10.0; // Position camera 10m in front of nose for good view
          frontOffset = -actualNose - noseDistance; // Move center back: nose + viewing distance
          groundOffset = -actualBottom - 2.0; // Extra 2m down for landing gear
          
          console.log(`[${logPrefix}] AIRPLANE POSITIONING FIXED:`);
          console.log(`[${logPrefix}] - Nose at Z=${actualNose}, Tail at Z=${actualTail}`);
          console.log(`[${logPrefix}] - Moving center back by ${-frontOffset}m (nose + ${noseDistance}m viewing distance)`);
          console.log(`[${logPrefix}] - Camera will be ${noseDistance}m in front of airplane nose`);
        }
        
        childModel.position.set(
          -centerX,            // Center the model horizontally using stored offset
          groundOffset,        // Position for proper ground contact
          frontOffset          // Move so correct face is at proper distance from camera
        );
        
        childModel.visible = true;
        
        console.log(`[${logPrefix}] Child positioned: ground=${groundOffset.toFixed(3)}m, front=${frontOffset.toFixed(3)}m, center=${(-centerX).toFixed(3)}m`);
        
        } // End of non-procedural cube positioning
        
        // STEP 3: CONTAINER POSITIONING (SIMPLIFIED PIVOT-BASED APPROACH)
        // The key insight: container origin IS the front-bottom center after proper child positioning
        
        // Simply position and rotate the container - the child positioning makes the pivot correct
        target.position.copy(targetPosition);
        target.quaternion.copy(rotationQuaternion);
        target.visible = true;
        
        // Add transparent bounding box for airplane positioning verification
        if (modelType === 'airplane') {
          try {
            console.log(`[${logPrefix}] Starting bounding box creation...`);
            console.log(`[${logPrefix}] Original dimensions:`, originalDimensions);
            
            // Get current scale from childModel
            const boxCurrentScale = childModel.scale.x; // Current scale factor
            console.log(`[${logPrefix}] Current scale:`, boxCurrentScale);
            
            // Remove any existing bounding box
            const existingBox = target.children.find(child => child.userData && child.userData.isBoundingBox);
            if (existingBox) {
              target.remove(existingBox);
              console.log(`[${logPrefix}] Removed existing bounding box`);
            }
            
            // Create simple box geometry first
            console.log(`[${logPrefix}] Creating BoxGeometry...`);
            const boxWidth = originalDimensions.x * boxCurrentScale;
            const boxHeight = originalDimensions.y * boxCurrentScale; 
            const boxDepth = originalDimensions.z * boxCurrentScale;
            console.log(`[${logPrefix}] Box dimensions: ${boxWidth.toFixed(2)} × ${boxHeight.toFixed(2)} × ${boxDepth.toFixed(2)}`);
            
            const boxGeometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
            console.log(`[${logPrefix}] BoxGeometry created successfully`);
            
            // Create solid wireframe box like testCube parameter
            console.log(`[${logPrefix}] Creating EdgesGeometry for solid box outline...`);
            const edges = new THREE.EdgesGeometry(boxGeometry);
            console.log(`[${logPrefix}] EdgesGeometry created successfully`);
            
            // Create material for solid box edges
            console.log(`[${logPrefix}] Creating material...`);
            const boxMaterial = new THREE.LineBasicMaterial({ 
              color: 0xff0000,  // Red box outline
              transparent: true, 
              opacity: 0.8,
              linewidth: 3
            });
            console.log(`[${logPrefix}] Material created successfully`);
            
            // Create line segments for box edges
            console.log(`[${logPrefix}] Creating LineSegments for box edges...`);
            const boundingBox = new THREE.LineSegments(edges, boxMaterial);
            console.log(`[${logPrefix}] Box edge LineSegments created successfully`);
            
            // Position bounding box to show actual airplane boundaries
            console.log(`[${logPrefix}] Positioning bounding box to match airplane...`);
            
            // The bounding box should be positioned so its front-bottom corner is at origin (0,0,0)
            // which matches where the airplane's front-bottom should be after child positioning
            // For positioning, use original unscaled distances
            const airplaneActualBottom = (window.realModelBottom || -0.0046);
            const airplaneActualFront = (window.realModelFront || 0.0649);
            
            // Position box so its front-bottom corner aligns with container origin
            // For centered model: move box back so front edge is at circle
            boundingBox.position.set(
              0,                          // Centered horizontally 
              boxHeight/2 + airplaneActualBottom * boxCurrentScale,  // Bottom edge at airplane bottom
              10.263                      // Move to match NOSE position (nose + viewing distance)
            );
            
            boundingBox.userData = { isBoundingBox: true };
            boundingBox.renderOrder = 10000; // Render on top
            console.log(`[${logPrefix}] Bounding box positioned at:`, boundingBox.position);
            console.log(`[${logPrefix}] Box shows: front-bottom corner at airplane's actual front-bottom`);
            
            // Add to target
            console.log(`[${logPrefix}] Adding to target...`);
            target.add(boundingBox);
            console.log(`[${logPrefix}] ✅ SOLID BOX OUTLINE ADDED SUCCESSFULLY: ${boxWidth.toFixed(2)}×${boxHeight.toFixed(2)}×${boxDepth.toFixed(2)}m`);
            
          } catch (boundingBoxError) {
            console.log(`[${logPrefix}] ❌ Bounding box creation failed at step:`, boundingBoxError);
            console.log(`[${logPrefix}] Error details:`, boundingBoxError.message, boundingBoxError.stack);
          }
        }
        
        console.log(`[${logPrefix}] Container positioned at:`, target.position, '✓');
        
        return true;
        
      } catch (error) {
        console.log(`[${config.logPrefix}] POSITIONING ERROR:`, error);
        return false;
      }
    }
    
    function placeCube(cubeNumber) {
      try {
        // Select which test cube to place
        let target, targetDimensions, targetLoaded;
        if (cubeNumber === 1) {
          target = testCube1Model;
          targetDimensions = testCube1Dimensions;
          targetLoaded = testCube1Loaded;
        } else if (cubeNumber === 2) {
          target = testCube2Model;
          targetDimensions = testCube2Dimensions;
          targetLoaded = testCube2Loaded;
        } else {
          console.log(`[PlaceCube] Invalid cube number: ${cubeNumber}`);
          return;
        }
        
        if (!targetLoaded || !target) {
          console.log(`[PlaceCube${cubeNumber}] Test cube not loaded yet`);
          return;
        }
        
        // Hide airplane and procedural objects (but keep both test cubes visible)
        if (model) model.visible = false;
        if (testCubeObj) testCubeObj.visible = false;
        cube.visible = false;
        
        // Position at reticle or camera fallback
        let targetPosition = new THREE.Vector3();
        let rotationQuaternion = new THREE.Quaternion();
        
        if (reticle.visible) {
          targetPosition.copy(reticle.position);
          rotationQuaternion.copy(reticle.quaternion);
        } else {
          // Fallback: place 2m in front of camera
          camera.getWorldPosition(targetPosition);
          const forward = new THREE.Vector3();
          camera.getWorldDirection(forward);
          targetPosition.add(forward.multiplyScalar(2));
          // Face camera
          const cameraDirection = new THREE.Vector3();
          camera.getWorldDirection(cameraDirection);
          const cubeForwardDirection = cameraDirection.clone().multiplyScalar(-1);
          cubeForwardDirection.y = 0;
          cubeForwardDirection.normalize();
          const defaultForward = new THREE.Vector3(0, 0, 1);
          rotationQuaternion.setFromUnitVectors(defaultForward, cubeForwardDirection);
        }
        
        // USE UNIFIED POSITIONING SYSTEM
        const actualBottom = window[`realModelBottom${cubeNumber}`] || 0;
        const actualFront = window[`realModelFront${cubeNumber}`] || (targetDimensions ? targetDimensions.z / 2 : 0.5);
        
        const success = positionModel({
          target: target,
          targetPosition: targetPosition,
          rotationQuaternion: rotationQuaternion,
          modelType: `testCube${cubeNumber}`,
          originalDimensions: targetDimensions,
          actualBottom: actualBottom,
          actualFront: actualFront,
          expectedHeight: null, // No scaling for test cubes
          logPrefix: `PlaceCube${cubeNumber}`
        });
        
        if (!success) {
          console.log(`[PlaceCube${cubeNumber}] UNIFIED POSITIONING FAILED`);
          return;
        }
        
        console.log(`[PlaceCube${cubeNumber}] GLB file: models/TESTBOX-${cubeNumber === 1 ? 'frontfacepivot' : 'centerpivot'}.glb`);
        
      } catch(err) {
        console.log(`[PlaceCube${cubeNumber}] Error:`, err);
      }
    }

    function onXRFrame(t, frame){
      const session = frame.session; const pose = frame.getViewerPose(refSpace);
      if (hitSource && refSpace) {
        const results = frame.getHitTestResults(hitSource);
        if (results && results.length) {
          const hitPose = results[0].getPose(refSpace);
          reticle.visible = true; 
          reticle.position.set(hitPose.transform.position.x, hitPose.transform.position.y, hitPose.transform.position.z);
          reticle.quaternion.set(hitPose.transform.orientation.x, hitPose.transform.orientation.y, hitPose.transform.orientation.z, hitPose.transform.orientation.w);
          hint.textContent = 'Surface found - tap Place';
          
          // Make Place button green when surface is detected
          if (placeBtn && !placeBtn.disabled) {
            placeBtn.classList.add('ready');
          }
          
          if (autoPlace && !autoPlaced) { try { place(); autoPlaced = true; console.log('[AutoPlace] via reticle'); } catch(_){} }
        } else {
          reticle.visible = false;
          hint.textContent = 'Move to find surface';
          
          // Remove green color when no surface detected
          if (placeBtn) {
            placeBtn.classList.remove('ready');
          }
        }
      }
      renderer.render(scene, camera);
    }

    renderer.setAnimationLoop(onXRFrame);

    // Bind UI early and robustly
    if (startBtn) startBtn.addEventListener('click', () => { console.log('[UI] Start AR clicked'); try { startAR(); } catch(e){ console.log('[UI] startAR failed', e); } });
    if (placeBtn) placeBtn.addEventListener('click', () => { console.log('[UI] Place clicked'); try { place(); } catch(e){ console.log('[UI] place failed', e); } });
    if (exitBtn) exitBtn.addEventListener('click', () => { console.log('[UI] Exit clicked'); try { const s = renderer.xr.getSession(); if (s) s.end(); } catch(_) {} });
    if (logsBtn) logsBtn.addEventListener('click', () => {
      try {
        const text = (window.__logBuffer||[]).join('\n');
        const blob = new Blob([text], {type:'text/plain'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'xr-min-logs.txt';
        document.body.appendChild(a); a.click(); document.body.removeChild(a);
        setTimeout(()=>URL.revokeObjectURL(url), 1000);
      } catch (e) { console.log('[UI] Download logs failed', e); }
    });

    if (autoPlace) {
      document.addEventListener('click', () => { if (renderer.xr.isPresenting) { place(); } }, { once: true });
    }

    console.log('[Init] XR minimal ready');
  })();
  </script>
</body>
</html>


