<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>WebXR AR - World Locked Model</title>
  <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
  <style>
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    /* Ensure AR canvas is transparent so the camera feed shows */
    html, body, a-scene { background: transparent !important; }
    canvas, .a-canvas { background-color: transparent !important; }
    #overlay { position: fixed; top: 0; left: 0; right: 0; }
    #ui { position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%); z-index: 10; }
    #placeBtn, #startBtn, #resetBtn {
      padding: 10px 16px; border-radius: 999px; border: none; background: #111; color: white; margin: 0 6px; font-weight: 600;
    }
    #hint { position: fixed; top: 16px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.6); color: #fff; padding: 8px 12px; border-radius: 8px; z-index: 10; }
  </style>
</head>
<body>
  <div id="overlay">
    <div id="hint">Tap Start AR. Move your phone to find a surface. Tap Place to anchor the model.</div>
    <div id="ui">
      <button id="backBtn" onclick="history.back()">Back</button>
      <button id="startBtn">Start AR</button>
      <button id="placeBtn" disabled>Place</button>
      <button id="resetBtn" disabled>Reset</button>
    </div>
  </div>

  <a-scene
    renderer="alpha: true; logarithmicDepthBuffer: true; antialias: true"
    webxr="mode: ar; optionalFeatures: hit-test,dom-overlay,anchors; overlayElement: #overlay"
    xr-mode-ui="enabled: true"
    embedded>

    <a-assets>
      <a-asset-item id="model" src="./models/7579_3K_V2.glb"></a-asset-item>
    </a-assets>

    <!-- Reticle -->
    <a-entity id="reticle" visible="false"
      geometry="primitive: ring; radiusInner: 0.07; radiusOuter: 0.08"
      material="color: #00FFAA; shader: flat; opacity: 0.9"
      rotation="-90 0 0"></a-entity>

    <!-- Model to place (scale 1) -->
    <a-entity id="worldModel" gltf-model="#model" scale="1 1 1" visible="false"></a-entity>

    <a-entity camera></a-entity>
  </a-scene>

  <script>
    (function() {
      const url = new URL(window.location.href);
      const safeMode = url.searchParams.get('safemode') === '1' || url.searchParams.get('safe') === '1';
      const sceneEl = document.querySelector('a-scene');
      const reticleEl = document.getElementById('reticle');
      const modelEl = document.getElementById('worldModel');
      const startBtn = document.getElementById('startBtn');
      const placeBtn = document.getElementById('placeBtn');
      const resetBtn = document.getElementById('resetBtn');
      const hintEl = document.getElementById('hint');
      const backBtn = document.getElementById('backBtn');

      let xrSession = null;
      let hitTestSource = null;
      let viewerSpace = null;
      let refSpace = null;
      let anchor = null; // optional XRAnchor if supported
      let haveHitTest = false;

      function supportsWebXR() {
        return navigator.xr && navigator.xr.isSessionSupported;
      }

      let starting = false;
      async function startAR() {
        if (starting) return; starting = true;
        if (!supportsWebXR()) {
          alert('WebXR AR not supported on this device/browser. Try Chrome/Android or Safari iOS 17+.');
          starting = false; return;
        }
        const supported = await navigator.xr.isSessionSupported('immersive-ar');
        if (!supported) {
          alert('Immersive AR session not supported.');
          starting = false; return;
        }
        console.log('[WebXR] Requesting AR session via navigator.xr.requestSession...');
        try {
          const overlay = document.getElementById('overlay');
          const required = ['hit-test'];
          // Request local-floor if available
          required.push('local-floor');
          const optional = ['anchors'];
          if (!safeMode) {
            optional.push('dom-overlay');
          }
          const sessionInit = {
            requiredFeatures: required,
            optionalFeatures: optional,
            domOverlay: safeMode ? undefined : { root: overlay }
          };
          console.log('[WebXR] sessionInit', sessionInit);
          const session = await navigator.xr.requestSession('immersive-ar', sessionInit);
          sceneEl.renderer.xr.setSession(session);
          // Ensure transparent background in AR
          if (sceneEl.renderer && sceneEl.renderer.setClearColor) {
            sceneEl.renderer.setClearColor(0x000000, 0);
          }
          hintEl.textContent = 'AR session started. Move to find a surface.';
          // Proactively run AR init in case framework event doesn't fire
          try { await onEnterVR(); } catch (err) { console.warn('AR init fallback failed', err); }
        } catch (e) {
          console.error('[WebXR] requestSession failed', e);
          hintEl.textContent = 'Could not start AR session. Ensure camera permission is allowed. Use Back to return to marker mode.';
          starting = false; return;
        }
        // If A-Frame does not dispatch enter-vr automatically, do minimal init
        setTimeout(() => {
          if (!sceneEl.renderer || !sceneEl.renderer.xr || !sceneEl.renderer.xr.getSession()) {
            hintEl.textContent = 'AR session not active. Try again or use Back to return to marker mode.';
            starting = false;
          }
        }, 1500);
      }

      async function onEnterVR() {
        // Called when AR session starts
        xrSession = sceneEl.renderer.xr.getSession();
        refSpace = sceneEl.renderer.xr.getReferenceSpace();

        try {
          viewerSpace = await xrSession.requestReferenceSpace('viewer');
          const hitSource = await xrSession.requestHitTestSource({ space: viewerSpace });
          hitTestSource = hitSource;
          haveHitTest = true;
          placeBtn.disabled = false;
          resetBtn.disabled = false;
          hintEl.textContent = 'Move to find a surface, then tap Place.';
        } catch (e) {
          console.warn('Hit-test not available', e);
          haveHitTest = false;
          placeBtn.disabled = false; // Allow fallback placement
          resetBtn.disabled = false;
          hintEl.textContent = 'Hit-test unavailable. Tap Place to drop model 2m ahead.';
        }

        xrSession.addEventListener('end', onSessionEnd);
      }

      function onSessionEnd() {
        xrSession = null;
        hitTestSource = null;
        viewerSpace = null;
        refSpace = null;
        anchor = null;
        reticleEl.setAttribute('visible', false);
        placeBtn.disabled = true;
        resetBtn.disabled = true;
        hintEl.textContent = 'AR session ended. Tap Start AR to try again or go back to marker mode.';
      }

      // Update reticle each frame
      sceneEl.addEventListener('renderstart', () => {
        // Keep renderer alpha 0 during AR so the camera feed is visible
        if (sceneEl.renderer && sceneEl.renderer.setClearColor) {
          sceneEl.renderer.setClearColor(0x000000, 0);
        }
        sceneEl.renderer.setAnimationLoop((timestamp, frame) => {
          sceneEl.frame = frame;
          if (!frame || !hitTestSource || !refSpace) { reticleEl.setAttribute('visible', false); return; }
          const results = frame.getHitTestResults(hitTestSource);
          if (results && results.length > 0) {
            const pose = results[0].getPose(refSpace);
            if (pose) {
              const mat = new THREE.Matrix4();
              mat.fromArray(pose.transform.matrix);
              const o3d = reticleEl.object3D;
              o3d.matrix.copy(mat);
              o3d.matrix.decompose(o3d.position, o3d.quaternion, o3d.scale);
              reticleEl.setAttribute('visible', true);
            }
          } else {
            reticleEl.setAttribute('visible', false);
          }
        });
      });

      async function placeAtReticle() {
        const m = modelEl.object3D;
        if (haveHitTest && reticleEl.getAttribute('visible')) {
          const r = reticleEl.object3D;
          m.position.copy(r.position);
          m.quaternion.copy(r.quaternion);
        } else {
          // Fallback: place 2m in front of camera
          const cam = sceneEl.camera;
          if (!cam) return;
          const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(cam.quaternion);
          const pos = new THREE.Vector3().copy(cam.position).add(dir.multiplyScalar(2));
          m.position.copy(pos);
          m.quaternion.copy(cam.quaternion);
        }
        modelEl.setAttribute('visible', true);
      }

      function resetPlacement() {
        modelEl.setAttribute('visible', false);
        anchor = null;
      }

      startBtn.addEventListener('click', startAR);
      placeBtn.addEventListener('click', placeAtReticle);
      resetBtn.addEventListener('click', resetPlacement);

      sceneEl.addEventListener('enter-vr', onEnterVR);
      sceneEl.addEventListener('exit-vr', onSessionEnd);

      // Ensure overlay receives clicks while in AR (dom-overlay feature)
      document.addEventListener('click', (e) => {
        // no-op, just ensures DOM overlay is interactive
      });
    })();
  </script>
</body>
</html>


