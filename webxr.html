<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>WebXR AR - World Locked Model</title>
  <script>
    // Ensure first log is the build version and capture all logs early
    (function(){
      window.BUILD_NUMBER = 23; // INCREMENT BEFORE COMMIT
      if (!window.__logBuffer) window.__logBuffer = [];
      const origLog = console.log.bind(console);
      const origWarn = console.warn.bind(console);
      const origErr = console.error.bind(console);
      function fmt(arg){
        try { if (arg instanceof Error) return arg.stack || String(arg); if (typeof arg === 'object') return JSON.stringify(arg); return String(arg); }
        catch(_) { return String(arg); }
      }
      function push(level, args){
        const ts = new Date().toISOString();
        let msg = Array.from(args).map(fmt).join(' ');
        if (typeof msg === 'string' && msg.length > 2000) {
          msg = msg.slice(0, 2000) + ' â€¦[truncated]';
        }
        window.__logBuffer.push(`[${ts}] [${level}] ${msg}`);
        if (window.__logBuffer.length > 2000) window.__logBuffer.shift();
      }
      console.log = function(){ push('LOG', arguments); origLog.apply(console, arguments); };
      console.warn = function(){ push('WARN', arguments); origWarn.apply(console, arguments); };
      console.error = function(){ push('ERROR', arguments); origErr.apply(console, arguments); };
      window.addEventListener('error', (e)=>{ push('ONERROR', [e.message, e.filename+':'+e.lineno]); });
      window.addEventListener('unhandledrejection', (e)=>{ push('REJECTION', [e.reason]); });
      console.log('[Build] webxr.html build', window.BUILD_NUMBER);
    })();
  </script>
  <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
  <style>
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    /* Ensure AR canvas is transparent so the camera feed shows */
    html, body, a-scene { background: transparent !important; }
    canvas, .a-canvas { background-color: transparent !important; }
    /* Make overlay cover the whole viewport so buttons are clickable in AR */
    #overlay { position: fixed; inset: 0; z-index: 20; }
    #ui { position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%); z-index: 10; }
    #placeBtn, #startBtn, #resetBtn {
      padding: 10px 16px; border-radius: 999px; border: none; background: #111; color: white; margin: 0 6px; font-weight: 600;
    }
    /* Place is green when a valid surface is targeted (reticle visible) */
    #placeBtn.ok { background: #16a34a; }
    #placeBtn.ok:active { background: #15803d; }
    #hint { position: fixed; top: 16px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.6); color: #fff; padding: 8px 12px; border-radius: 8px; z-index: 10; }
    #buildBadge { position: fixed; top: 16px; right: 16px; background: rgba(17,17,17,0.8); color: #fff; padding: 6px 10px; border-radius: 999px; font-size: 12px; z-index: 10; }
  </style>
</head>
<body>
    <div id="overlay">
    <div id="hint">Tap Start AR. Move your phone to find a surface. Tap Place to anchor the model.</div>
      <div id="buildBadge">build 6</div>
    <div id="ui">
      <button id="backBtn" onclick="history.back()">Back</button>
      <button id="copyLogsBtn" title="Download all console logs">Download logs</button>
      <button id="startBtn">Start AR</button>
      <button id="placeBtn" disabled>Place</button>
      <button id="resetBtn" disabled>Reset</button>
    </div>
  </div>

  <a-scene
    renderer="alpha: true; antialias: true"
    webxr="optionalFeatures: hit-test,dom-overlay,anchors; overlayElement: #overlay"
    xr-mode-ui="enabled: true"
    embedded>

    <a-assets>
      <!-- Use existing asset to avoid load failure; switch back to V2 once the file exists -->
      <a-asset-item id="model" src="./models/7579_3K_V1.glb"></a-asset-item>
    </a-assets>

    <!-- Reticle -->
    <a-entity id="reticle" visible="false"
      geometry="primitive: ring; radiusInner: 0.12; radiusOuter: 0.14"
      material="color: #00FFAA; shader: flat; opacity: 0.95"
      rotation="-90 0 0"></a-entity>

    <!-- Model to place (scale 1). glTF is attached via JS unless forceCube=1 -->
    <a-entity id="worldModel" scale="1 1 1" visible="false"></a-entity>

    <!-- Basic lights so GLTF/placeholder are visible -->
    <a-entity light="type: ambient; intensity: 1"></a-entity>
    <a-entity light="type: directional; intensity: 0.8" position="0 1 0"></a-entity>

    <a-entity camera></a-entity>
  </a-scene>

  <script>
    (function() {
      // Mirror early BUILD_NUMBER into badge, but don't duplicate version log
      const badgeEl = document.getElementById('buildBadge');
      if (badgeEl && typeof window.BUILD_NUMBER !== 'undefined') {
        badgeEl.textContent = `build ${window.BUILD_NUMBER}`;
      }
      const url = new URL(window.location.href);
      const safeMode = url.searchParams.get('safemode') === '1' || url.searchParams.get('safe') === '1';
      const forceBasic = url.searchParams.get('forceBasic') === '1';
      const forceCube = url.searchParams.get('forceCube') === '1';
      const forceRaw = url.searchParams.get('forceRaw') === '1';
      const autoPlace = url.searchParams.get('autoPlace') === '1';
      const debugHud = url.searchParams.get('hud') === '1' || url.searchParams.get('debugHud') === '1';
      const headLock = url.searchParams.get('headlock') === '1' || url.searchParams.get('hl') === '1';
      const big = url.searchParams.get('big') === '1';
      const opaqueBg = url.searchParams.get('opaque') === '1';
      const bgColorParam = url.searchParams.get('bg'); // hex like ff0000
      const alwaysBox = url.searchParams.get('ab') === '1' || url.searchParams.get('always') === '1';
      const verbose = url.searchParams.get('diag') === '1' || url.searchParams.get('v') === '1';
      const fullQuad = url.searchParams.get('fg') === '1' || url.searchParams.get('full') === '1';
      const domBox = url.searchParams.get('dom') === '1';
      const glClear = url.searchParams.get('glclear') === '1';
      const easyExit = url.searchParams.get('easyExit') !== '0';
      const autoExitMs = parseInt(url.searchParams.get('autoExitMs') || '0', 10) || 0;
      const noOverlay = url.searchParams.get('noOverlay') === '1' || url.searchParams.get('nool') === '1';
      const wire = url.searchParams.get('wire') === '1';
      const noAlpha = url.searchParams.get('noAlpha') === '1';
      const sceneEl = document.querySelector('a-scene');
      const reticleEl = document.getElementById('reticle');
      const modelEl = document.getElementById('worldModel');
      var rawCube = null; // Optional raw THREE cube bypassing A-Frame for maximum visibility
      var afCubeEl = null; // A-Frame fallback cube for guaranteed visibility
      var headLocked = null; // Object fixed to camera for last-resort visibility (follows camera)
      var alwaysBoxEl = null; // Always-visible A-Frame box at fixed world pose
      var fullQuadMesh = null; // Large plane in front of camera to prove 3D draw path
      var gridHelper = null; // Wire grid for visibility
      // Log when the GLB finishes loading and optionally force basic materials for visibility
      modelEl.addEventListener('model-loaded', (e) => {
        console.log('[Model] GLB loaded');
        if (forceBasic && modelEl.object3D) {
          try {
            modelEl.object3D.traverse((child) => {
              if (child.material) {
                const map = child.material.map || null;
                child.material = new THREE.MeshBasicMaterial({ color: 0xffffff, map });
              }
            });
            console.log('[Model] Applied basic materials for visibility');
          } catch(err) { console.warn('Force basic failed', err); }
        }
      });
      // Attach model or placeholder depending on URL params
      if (forceCube) {
        try {
          modelEl.removeAttribute('gltf-model');
          modelEl.setAttribute('geometry', 'primitive: box; width: 0.6; height: 0.6; depth: 0.6');
          modelEl.setAttribute('material', 'color: #4ecdc4; shader: flat; side: double');
          console.log('[Model] Forcing cube placeholder via URL param forceCube=1');
        } catch(_) {}
      } else {
        modelEl.setAttribute('gltf-model', '#model');
      }
      // Also create a raw THREE cube if requested (bypasses A-Frame entity visibility)
      if (forceRaw) {
        try {
          const size = big ? 1.2 : 0.4;
          const g = new THREE.BoxGeometry(size, size, size);
          const mat = new THREE.MeshBasicMaterial({ color: 0xff00ff });
          if (mat.depthTest !== undefined) mat.depthTest = false;
          if (mat.depthWrite !== undefined) mat.depthWrite = false;
          if (mat.side !== undefined) mat.side = THREE.DoubleSide;
          rawCube = new THREE.Mesh(g, mat);
          rawCube.visible = false;
          try { rawCube.layers.set(0); } catch(_) {}
          sceneEl.object3D.add(rawCube);
          // Draw raw cube on top to confirm placement visually
          rawCube.renderOrder = 9999;
          // Create an A-Frame cube as a second, independent visualization path
          afCubeEl = document.createElement('a-entity');
          afCubeEl.setAttribute('id', 'afCube');
          const afSize = big ? 1.2 : 0.6;
          afCubeEl.setAttribute('geometry', `primitive: box; width: ${afSize}; height: ${afSize}; depth: ${afSize}`);
          afCubeEl.setAttribute('material', 'color: #ff00ff; shader: flat; side: double');
          afCubeEl.setAttribute('visible', 'false');
          sceneEl.appendChild(afCubeEl);
          afCubeEl.addEventListener('loaded', () => {
            try {
              const obj = afCubeEl.getObject3D('mesh') || afCubeEl.object3D;
              if (obj) {
                obj.renderOrder = 9999;
                try { obj.layers.set(0); } catch(_) {}
                if (obj.material) {
                  obj.material.depthTest = false;
                  obj.material.depthWrite = false;
                  obj.material.transparent = false;
                  obj.material.needsUpdate = true;
                }
              }
            } catch(_) {}
          });
          console.log('[Model] forceRaw=1 active: using raw THREE.Mesh cube');
        } catch (e) { console.warn('Create raw cube failed', e); }
      }

      // Add a bright HUD plane always in front of the camera for visibility debugging
      if (debugHud) {
        try {
          const hud = document.createElement('a-entity');
          hud.setAttribute('id', 'hudPlane');
          hud.setAttribute('geometry', 'primitive: plane; width: 0.25; height: 0.25');
          hud.setAttribute('material', 'color: #ffffff; shader: flat; side: double');
          hud.setAttribute('visible', 'true');
          document.querySelector('a-scene').appendChild(hud);
          const updateHud = () => {
            const cam = sceneEl.camera;
            if (!cam) return;
            const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(cam.quaternion);
            const pos = new THREE.Vector3().copy(cam.position).add(dir.multiplyScalar(0.6));
            hud.setAttribute('position', `${pos.x} ${pos.y} ${pos.z}`);
            const euler = new THREE.Euler().setFromQuaternion(cam.quaternion, 'YXZ');
            hud.setAttribute('rotation', `${THREE.MathUtils.radToDeg(euler.x)} ${THREE.MathUtils.radToDeg(euler.y)} ${THREE.MathUtils.radToDeg(euler.z)}`);
          };
          sceneEl.addEventListener('renderstart', () => {
            sceneEl.renderer.setAnimationLoop(() => { updateHud(); });
          });
        } catch(_) {}
      }

      // Create an always-visible A-Frame box at a fixed world pose to sanity-check rendering
      if (alwaysBox) {
        try {
          alwaysBoxEl = document.createElement('a-entity');
          const s = big ? 0.8 : 0.5;
          alwaysBoxEl.setAttribute('id', 'alwaysBox');
          alwaysBoxEl.setAttribute('geometry', `primitive: box; width: ${s}; height: ${s}; depth: ${s}`);
          alwaysBoxEl.setAttribute('material', 'color: #ff0000; shader: flat; opacity: 1; side: double');
          alwaysBoxEl.setAttribute('position', '0 1 -1');
          alwaysBoxEl.setAttribute('visible', 'true');
          document.querySelector('a-scene').appendChild(alwaysBoxEl);
          alwaysBoxEl.addEventListener('loaded', ()=>{
            try {
              const obj = alwaysBoxEl.getObject3D('mesh') || alwaysBoxEl.object3D;
              if (obj && obj.material){ obj.material.depthTest=false; obj.material.depthWrite=false; obj.renderOrder=9999; obj.material.needsUpdate=true; }
            } catch(_){}
          });
          console.log('[Debug] Always-visible box created');
        } catch(_) { console.warn('Always box creation failed'); }
      }

      // Add a large DOM overlay red box to verify DOM overlay layer visibility
      if (domBox) {
        try {
          const d = document.createElement('div'); d.id = 'domDebugBox';
          d.style.cssText = 'position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:160px;height:160px;background:rgba(255,0,0,0.6);z-index:9999;border-radius:16px;';
          document.body.appendChild(d);
          console.log('[Debug] DOM overlay debug box added');
        } catch(_) {}
      }

      // Create a head-locked cube that sits in front of the camera (follows each frame)
      if (headLock) {
        try {
          const s = big ? 0.5 : 0.25;
          const g2 = new THREE.BoxGeometry(s, s, s);
          const m2 = new THREE.MeshBasicMaterial({ color: 0x00ff88 });
          headLocked = new THREE.Mesh(g2, m2);
          headLocked.visible = true;
          headLocked.renderOrder = 9999;
          m2.depthTest = false; m2.depthWrite = false;
          try { headLocked.layers.set(0); } catch(_) {}
          sceneEl.object3D.add(headLocked);
          console.log('[Debug] Head-locked cube created (follows camera)');
        } catch(_) { console.warn('Head-locked cube creation failed'); }
      }
      const startBtn = document.getElementById('startBtn');
      const copyLogsBtn = document.getElementById('copyLogsBtn');
      const placeBtn = document.getElementById('placeBtn');
      const resetBtn = document.getElementById('resetBtn');
      const hintEl = document.getElementById('hint');
      const backBtn = document.getElementById('backBtn');

      let xrSession = null;
      let hitTestSource = null;
      let viewerSpace = null;
      let refSpace = null;
      let anchor = null; // optional XRAnchor if supported
      let haveHitTest = false;
      // Cache the last valid XR viewer pose (updated inside the XR frame callback)
      let lastViewerPosition = new THREE.Vector3();
      let lastViewerOrientation = new THREE.Quaternion();
      let haveViewerPose = false;
      // Debug helpers attached to the placed model for visibility confirmation
      let axesHelper = null;
      let bboxHelper = null;
      // let rawCube = null; // Optional raw THREE cube bypassing A-Frame for maximum visibility
      // rawCube declared earlier

      function supportsWebXR() {
        return navigator.xr && navigator.xr.isSessionSupported;
      }

      let starting = false;
      async function startAR() {
        // Toggle behavior: if a session exists, end it first
        if (xrSession) {
          try { await xrSession.end(); } catch (_) {}
          return;
        }
        if (starting) return; starting = true;
        if (!supportsWebXR()) {
          alert('WebXR AR not supported on this device/browser. Try Chrome/Android or Safari iOS 17+.');
          starting = false; return;
        }
        const supported = await navigator.xr.isSessionSupported('immersive-ar');
        if (!supported) {
          alert('Immersive AR session not supported.');
          starting = false; return;
        }
        console.log('[WebXR] Requesting AR session via navigator.xr.requestSession...');
        try {
          const overlay = document.getElementById('overlay');
          const required = ['hit-test'];
          // Request local-floor if available
          required.push('local-floor');
          const optional = ['anchors'];
          if (!safeMode && !noOverlay) {
            optional.push('dom-overlay');
          }
          const sessionInit = {
            requiredFeatures: required,
            optionalFeatures: optional,
            domOverlay: (safeMode || noOverlay) ? undefined : { root: overlay }
          };
          console.log('[WebXR] sessionInit', sessionInit);
          const session = await navigator.xr.requestSession('immersive-ar', sessionInit);
          sceneEl.renderer.xr.setSession(session);
          if (startBtn) startBtn.textContent = 'Exit AR';
          // Ensure transparent background in AR
          if (sceneEl.renderer && sceneEl.renderer.setClearColor) {
            sceneEl.renderer.setClearColor(0x000000, noAlpha ? 1 : 0);
          }
          // Ensure in-page console is visible once AR starts
          if (window.eruda && typeof eruda.show === 'function') { try { eruda.show(); } catch(e){} }
          hintEl.textContent = 'AR session started. Move to find a surface.';
          // Proactively run AR init in case framework event doesn't fire
          try { await onEnterVR(); } catch (err) { console.warn('AR init fallback failed', err); }
          // Easy exit: double-tap select or timeout
          if (easyExit && session) {
            let lastTap = 0;
            const onSelect = () => {
              const now = Date.now();
              if (now - lastTap < 600) {
                try { session.end(); } catch(_) {}
              }
              lastTap = now;
            };
            session.addEventListener('select', onSelect);
            if (autoExitMs > 0) {
              setTimeout(() => { try { if (sceneEl.renderer.xr.getSession()) session.end(); } catch(_) {} }, autoExitMs);
            }
          }
        } catch (e) {
          console.error('[WebXR] requestSession failed', e);
          hintEl.textContent = 'Could not start AR session. Ensure camera permission is allowed. Use Back to return to marker mode.';
          starting = false; return;
        }
        // If A-Frame does not dispatch enter-vr automatically, do minimal init
        setTimeout(() => {
          if (!sceneEl.renderer || !sceneEl.renderer.xr || !sceneEl.renderer.xr.getSession()) {
            hintEl.textContent = 'AR session not active. Try again or use Back to return to marker mode.';
            starting = false;
          }
        }, 1500);
      }

      async function onEnterVR() {
        // Called when AR session starts
        xrSession = sceneEl.renderer.xr.getSession();
        refSpace = sceneEl.renderer.xr.getReferenceSpace();
        if (!refSpace && xrSession) {
          try {
            refSpace = await xrSession.requestReferenceSpace('local-floor');
          } catch (e1) {
            try {
              refSpace = await xrSession.requestReferenceSpace('local');
            } catch (e2) {
              console.warn('Could not obtain reference space', e1, e2);
            }
          }
        }

        try {
          viewerSpace = await xrSession.requestReferenceSpace('viewer');
          const hitSource = await xrSession.requestHitTestSource({ space: viewerSpace });
          hitTestSource = hitSource;
          haveHitTest = true;
          placeBtn.disabled = false;
          resetBtn.disabled = false;
          console.log('[WebXR] Hit-test ready. Buttons enabled.');
          hintEl.textContent = 'Move to find a surface, then tap Place.';
          // Optionally auto-place once when a hit is available
          if (autoPlace) {
            setTimeout(() => { try { placeAtReticle(); } catch(_) {} }, 200);
          }
        } catch (e) {
          console.warn('Hit-test not available', e);
          haveHitTest = false;
          placeBtn.disabled = false; // Allow fallback placement
          resetBtn.disabled = false;
          hintEl.textContent = 'Hit-test unavailable. Tap Place to drop model 2m ahead.';
        }

        xrSession.addEventListener('end', onSessionEnd);
      }

      function onSessionEnd() {
        xrSession = null;
        hitTestSource = null;
        viewerSpace = null;
        refSpace = null;
        anchor = null;
        reticleEl.setAttribute('visible', false);
        placeBtn.disabled = true;
        resetBtn.disabled = true;
        hintEl.textContent = 'AR session ended. Tap Start AR to try again or go back to marker mode.';
        if (startBtn) startBtn.textContent = 'Start AR';
      }

      // Update per-frame without overriding A-Frame's renderer loop
      sceneEl.addEventListener('renderstart', () => {
        if (sceneEl.renderer && sceneEl.renderer.setClearColor) {
          try {
            const col = bgColorParam ? parseInt(bgColorParam, 16) : 0xff0000;
            sceneEl.renderer.setClearColor(opaqueBg ? col : 0x000000, opaqueBg ? 1 : 0);
          } catch(_) {
            sceneEl.renderer.setClearColor(opaqueBg ? 0xff0000 : 0x000000, opaqueBg ? 1 : 0);
          }
        }
        // Create a large red plane 0.4m in front of camera (no transparency)
        if (fullQuad && !fullQuadMesh) {
          try {
            const geom = new THREE.PlaneGeometry(big ? 1.2 : 0.8, big ? 1.2 : 0.8);
          const mat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            mat.depthTest = false; mat.depthWrite = false;
            fullQuadMesh = new THREE.Mesh(geom, mat);
            fullQuadMesh.renderOrder = 9999;
          try { fullQuadMesh.layers.set(0); } catch(_) {}
            sceneEl.object3D.add(fullQuadMesh);
            console.log('[Debug] Full-quad created');
          } catch(_) { console.warn('Full-quad creation failed'); }
        }
        if (wire && !gridHelper) {
          try {
            gridHelper = new THREE.GridHelper(2, 20, 0x00ff00, 0x00ff00);
            gridHelper.material.depthTest = false;
            gridHelper.material.depthWrite = false;
            gridHelper.renderOrder = 9999;
            sceneEl.object3D.add(gridHelper);
            console.log('[Debug] Grid helper created');
          } catch(_) {}
        }
        try { sceneEl.setAttribute('xr-updater', ''); } catch(_) {}
      });

      // Component that runs each frame and updates reticle and debug followers
      try {
        AFRAME.registerComponent('xr-updater', {
          tick: function () {
            const frame = (sceneEl && sceneEl.renderer && sceneEl.renderer.xr) ? sceneEl.renderer.xr.getFrame() : null;
            if (verbose && !this._onceLogged) {
              this._onceLogged = true;
              try { console.log('[Diag] scene children=', sceneEl.object3D.children?.length, 'camera pos=', sceneEl.camera?.position); } catch(_) {}
            }
            // Optional raw GL clear to verify we can affect framebuffer
            if (glClear && sceneEl.renderer) {
              try {
                const gl = sceneEl.renderer.getContext();
                gl.disable(gl.DEPTH_TEST);
                gl.clearColor(0, 1, 0, 1); // green
                gl.clear(gl.COLOR_BUFFER_BIT);
              } catch(_) {}
            }
            // Update head-locked follower
            if (headLocked && sceneEl.camera) {
              try {
                const cam = sceneEl.camera;
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(cam.quaternion).normalize();
                const pos = new THREE.Vector3().copy(cam.position).add(forward.multiplyScalar(big ? 0.8 : 0.5));
                headLocked.position.copy(pos);
                headLocked.quaternion.copy(cam.quaternion);
              } catch(_) {}
            }
            // Keep full-quad in front of camera
            if (fullQuadMesh && sceneEl.camera) {
              try {
                const cam = sceneEl.camera;
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(cam.quaternion).normalize();
                const pos = new THREE.Vector3().copy(cam.position).add(forward.multiplyScalar(0.4));
                fullQuadMesh.position.copy(pos);
                fullQuadMesh.quaternion.copy(cam.quaternion);
              } catch(_) {}
            }
            // Keep grid under the camera
            if (gridHelper && sceneEl.camera) {
              try {
                const cam = sceneEl.camera;
                gridHelper.position.set(cam.position.x, cam.position.y - 0.2, cam.position.z - 0.8);
                gridHelper.quaternion.copy(cam.quaternion);
              } catch(_) {}
            }
            if (!frame || !hitTestSource || !refSpace) { reticleEl.setAttribute('visible', false); return; }
            try {
              const vp = frame.getViewerPose(refSpace);
              if (vp && vp.views && vp.views[0]) {
                const t = vp.transform;
                lastViewerPosition.set(t.position.x, t.position.y, t.position.z);
                lastViewerOrientation.set(t.orientation.x, t.orientation.y, t.orientation.z, t.orientation.w);
                haveViewerPose = true;
              }
            } catch (_) {}
            const results = frame.getHitTestResults(hitTestSource);
            if (results && results.length > 0) {
              const pose = results[0].getPose(refSpace);
              if (pose) {
                const mat = new THREE.Matrix4();
                mat.fromArray(pose.transform.matrix);
                const o3d = reticleEl.object3D;
                o3d.matrix.copy(mat);
                o3d.matrix.decompose(o3d.position, o3d.quaternion, o3d.scale);
                reticleEl.setAttribute('visible', true);
                if (placeBtn) placeBtn.classList.add('ok');
                return;
              }
            }
            reticleEl.setAttribute('visible', false);
            if (placeBtn) placeBtn.classList.remove('ok');
          }
        });
      } catch (_) {}

      async function placeAtReticle() {
        console.log('[Place] begin. reticleVisible=', reticleEl.getAttribute('visible'), 'haveHitTest=', haveHitTest);
        const m = (forceRaw && rawCube) ? rawCube : modelEl.object3D;
        if (!m) { console.warn('[Place] No target object to place'); return; }
        if (haveHitTest && reticleEl.getAttribute('visible')) {
          const r = reticleEl.object3D;
          m.position.copy(r.position);
          m.quaternion.copy(r.quaternion);
          console.log('[Place] Using reticle pose', m.position);
        } else {
          // Fallback: place ~2m in front of last known viewer pose, else camera
          if (haveViewerPose) {
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(lastViewerOrientation).normalize();
            const pos = new THREE.Vector3().copy(lastViewerPosition).add(forward.multiplyScalar(1));
            m.position.copy(pos);
            m.quaternion.copy(lastViewerOrientation);
            console.log('[Place] Using cached viewer pose', m.position);
          } else {
            const cam = sceneEl.camera;
            if (!cam) { console.warn('[Place] No viewer pose and no camera'); return; }
            const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(cam.quaternion);
            const pos = new THREE.Vector3().copy(cam.position).add(dir.multiplyScalar(1));
            m.position.copy(pos);
            m.quaternion.copy(cam.quaternion);
            console.log('[Place] Using camera fallback', m.position);
          }
        }
        // Nudge up slightly to avoid z-fighting with the detected plane
        try { m.position.y += 0.08; } catch(_) {}
        if (forceRaw && rawCube) {
          rawCube.visible = true;
          // Mirror placement to A-Frame cube as well for maximum compatibility
          try {
            if (afCubeEl) {
              afCubeEl.setAttribute('position', `${m.position.x} ${m.position.y} ${m.position.z}`);
              const eulerTmp = new THREE.Euler().setFromQuaternion(m.quaternion, 'YXZ');
              afCubeEl.setAttribute('rotation', `${THREE.MathUtils.radToDeg(eulerTmp.x)} ${THREE.MathUtils.radToDeg(eulerTmp.y)} ${THREE.MathUtils.radToDeg(eulerTmp.z)}`);
              afCubeEl.setAttribute('visible', 'true');
              afCubeEl.object3D.updateMatrixWorld(true);
            }
          } catch(_) {}
          console.log('[Place] Showing raw cube');
        } else {
          modelEl.setAttribute('visible', true);
        }
        // Sync A-Frame attributes so transforms persist
        try {
          const euler = new THREE.Euler().setFromQuaternion(m.quaternion, 'YXZ');
          const rot = {
            x: THREE.MathUtils.radToDeg(euler.x),
            y: THREE.MathUtils.radToDeg(euler.y),
            z: THREE.MathUtils.radToDeg(euler.z)
          };
          if (!(forceRaw && rawCube)) {
            modelEl.setAttribute('position', `${m.position.x} ${m.position.y} ${m.position.z}`);
            modelEl.setAttribute('rotation', `${rot.x} ${rot.y} ${rot.z}`);
          }
          // Always update AF fallback cube if present
          if (afCubeEl) {
            afCubeEl.setAttribute('position', `${m.position.x} ${m.position.y} ${m.position.z}`);
            afCubeEl.setAttribute('rotation', `${rot.x} ${rot.y} ${rot.z}`);
          }
        } catch (_) {}
        // Auto-rescale model to a reasonable size (skip if forceCube or forceRaw; cubes already sized)
        try {
          if (!forceCube && !(forceRaw && rawCube)) {
            const bbox = new THREE.Box3().setFromObject(m);
            const size = new THREE.Vector3(); bbox.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z);
            if (Number.isFinite(maxDim) && maxDim > 0) {
              const target = 0.6; // meters
              let factor = target / maxDim;
              factor = Math.min(Math.max(factor, 0.05), 5);
              const curScale = modelEl.getAttribute('scale') || {x:1,y:1,z:1};
              const newScale = `${curScale.x * factor} ${curScale.y * factor} ${curScale.z * factor}`;
              modelEl.setAttribute('scale', newScale);
              console.log('[Place] Rescaled model factor=', factor, 'newScale=', newScale);
            }
          }
        } catch (e) { console.warn('Rescale failed', e); }
        // Add/update bright debug helpers to make placement undeniably visible
        try {
          if (!axesHelper) {
            axesHelper = new THREE.AxesHelper(0.5);
            const mh = axesHelper.material; // material is array-like on AxesHelper; guard below
            if (mh && mh.depthTest !== undefined) mh.depthTest = false;
            axesHelper.renderOrder = 9999;
            m.add(axesHelper);
          }
          // Remove existing bbox helper if any, then create a fresh one around current object
          if (bboxHelper) {
            if (bboxHelper.parent) bboxHelper.parent.remove(bboxHelper);
            bboxHelper = null;
          }
          const tempBox = new THREE.Box3().setFromObject(m);
          bboxHelper = new THREE.Box3Helper(tempBox, new THREE.Color(0xff00ff));
          bboxHelper.renderOrder = 9999;
          if (bboxHelper.material && bboxHelper.material.depthTest !== undefined) {
            bboxHelper.material.depthTest = false;
          }
          // Attach helper to scene root so it's not affected by model's scale non-uniformity
          sceneEl.object3D.add(bboxHelper);
        } catch (e) { console.warn('Helpers failed', e); }
        m.updateMatrixWorld(true);
        console.log('[Place] visible=', (forceRaw && rawCube) ? rawCube.visible : modelEl.getAttribute('visible'), 'children=', m.children?.length, 'pos=', m.position);
      }

      function resetPlacement() {
        modelEl.setAttribute('visible', false);
        if (rawCube) { try { rawCube.visible = false; } catch(_) {} }
        if (afCubeEl) { try { afCubeEl.setAttribute('visible', 'false'); } catch(_) {} }
        anchor = null;
        try {
          if (axesHelper && axesHelper.parent) axesHelper.parent.remove(axesHelper);
          axesHelper = null;
          if (bboxHelper && bboxHelper.parent) bboxHelper.parent.remove(bboxHelper);
          bboxHelper = null;
        } catch(_){}
      }

      // Add logs to verify UI is interactive
      startBtn.addEventListener('click', () => { console.log('[UI] Start AR clicked'); startAR(); });
      if (copyLogsBtn) {
        copyLogsBtn.addEventListener('click', () => {
          console.log('[UI] Download logs');
          const text = (window.__logBuffer || []).join('\n');
          try {
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = 'webxr-logs.txt';
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
            setTimeout(() => URL.revokeObjectURL(url), 1000);
            hintEl.textContent = 'Logs download started.';
            setTimeout(() => { if (hintEl.textContent.includes('Logs')) hintEl.textContent = 'Move to find a surface, then tap Place.'; }, 2000);
          } catch (_) {
            hintEl.textContent = 'Download failed.';
            setTimeout(() => { if (hintEl.textContent.includes('Download failed')) hintEl.textContent = 'Move to find a surface, then tap Place.'; }, 2000);
          }
        });
      }
      placeBtn.addEventListener('click', () => { console.log('[UI] Place clicked'); placeAtReticle(); });
      resetBtn.addEventListener('click', () => { console.log('[UI] Reset clicked'); resetPlacement(); });

      sceneEl.addEventListener('enter-vr', onEnterVR);
      sceneEl.addEventListener('exit-vr', onSessionEnd);

      // Ensure overlay receives clicks while in AR (dom-overlay feature)
      document.addEventListener('click', (e) => {
        // no-op, just ensures DOM overlay is interactive
      });

      // If the GLB fails to load, fallback to a visible placeholder so placement works
      modelEl.addEventListener('model-error', (e) => {
        console.error('[Model] Failed to load GLB. Falling back to placeholder.', e?.detail);
        modelEl.removeAttribute('gltf-model');
        modelEl.setAttribute('geometry', 'primitive: box; width: 0.6; height: 0.6; depth: 0.6');
        modelEl.setAttribute('material', 'color: #4ecdc4; shader: flat; side: double');
      }, { once: true });

      // Also, if user taps Place and there is no mesh yet, attach a placeholder
      function ensurePlaceholderIfEmpty() {
        const hasChildren = modelEl.object3D && modelEl.object3D.children && modelEl.object3D.children.length > 0;
        if (!hasChildren) {
          modelEl.removeAttribute('gltf-model');
          modelEl.setAttribute('geometry', 'primitive: box; width: 0.6; height: 0.6; depth: 0.6');
          modelEl.setAttribute('material', 'color: #4ecdc4; shader: flat; side: double');
        }
      }

      const __originalPlace = placeAtReticle;
      placeAtReticle = async function() {
        ensurePlaceholderIfEmpty();
        // Show a brief debug marker where we intend to place
        try { const pos = modelEl.object3D.position; showDebugMarkerAt(pos); } catch(_){}
        return __originalPlace.apply(this, arguments);
      };

      function showDebugMarkerAt(positionVec3) {
        try {
          let marker = document.getElementById('debugMarker');
          if (!marker) {
            marker = document.createElement('a-entity');
            marker.setAttribute('id', 'debugMarker');
            marker.setAttribute('geometry', 'primitive: sphere; radius: 0.05');
            marker.setAttribute('material', 'color: #ffcc00; shader: flat; opacity: 0.9');
            document.querySelector('a-scene').appendChild(marker);
          }
          marker.setAttribute('position', `${positionVec3.x} ${positionVec3.y} ${positionVec3.z}`);
          marker.setAttribute('visible', true);
          setTimeout(() => { const m = document.getElementById('debugMarker'); if (m) m.setAttribute('visible', false); }, 1500);
        } catch (_) {}
      }
    })();
  </script>

  <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
  <script>
    eruda.init();
  </script>

</body>
</html>


