<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>WebXR AR - World Locked Model</title>
  <script>
    // Ensure first log is the build version and capture all logs early
    (function(){
      window.BUILD_NUMBER = 3; // INCREMENT BEFORE COMMIT
      if (!window.__logBuffer) window.__logBuffer = [];
      const origLog = console.log.bind(console);
      const origWarn = console.warn.bind(console);
      const origErr = console.error.bind(console);
      function fmt(arg){
        try { if (arg instanceof Error) return arg.stack || String(arg); if (typeof arg === 'object') return JSON.stringify(arg); return String(arg); }
        catch(_) { return String(arg); }
      }
      function push(level, args){
        const ts = new Date().toISOString();
        const msg = Array.from(args).map(fmt).join(' ');
        window.__logBuffer.push(`[${ts}] [${level}] ${msg}`);
        if (window.__logBuffer.length > 2000) window.__logBuffer.shift();
      }
      console.log = function(){ push('LOG', arguments); origLog.apply(console, arguments); };
      console.warn = function(){ push('WARN', arguments); origWarn.apply(console, arguments); };
      console.error = function(){ push('ERROR', arguments); origErr.apply(console, arguments); };
      window.addEventListener('error', (e)=>{ push('ONERROR', [e.message, e.filename+':'+e.lineno]); });
      window.addEventListener('unhandledrejection', (e)=>{ push('REJECTION', [e.reason]); });
      console.log('[Build] webxr.html build', window.BUILD_NUMBER);
    })();
  </script>
  <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
  <style>
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    /* Ensure AR canvas is transparent so the camera feed shows */
    html, body, a-scene { background: transparent !important; }
    canvas, .a-canvas { background-color: transparent !important; }
    /* Make overlay cover the whole viewport so buttons are clickable in AR */
    #overlay { position: fixed; inset: 0; z-index: 20; }
    #ui { position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%); z-index: 10; }
    #placeBtn, #startBtn, #resetBtn {
      padding: 10px 16px; border-radius: 999px; border: none; background: #111; color: white; margin: 0 6px; font-weight: 600;
    }
    #hint { position: fixed; top: 16px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.6); color: #fff; padding: 8px 12px; border-radius: 8px; z-index: 10; }
    #buildBadge { position: fixed; top: 16px; right: 16px; background: rgba(17,17,17,0.8); color: #fff; padding: 6px 10px; border-radius: 999px; font-size: 12px; z-index: 10; }
  </style>
</head>
<body>
  <div id="overlay">
    <div id="hint">Tap Start AR. Move your phone to find a surface. Tap Place to anchor the model.</div>
    <div id="buildBadge">build 2</div>
    <div id="ui">
      <button id="backBtn" onclick="history.back()">Back</button>
      <button id="copyLogsBtn" title="Copy all console logs">Copy logs</button>
      <button id="startBtn">Start AR</button>
      <button id="placeBtn" disabled>Place</button>
      <button id="resetBtn" disabled>Reset</button>
    </div>
  </div>

  <a-scene
    renderer="alpha: true; logarithmicDepthBuffer: true; antialias: true"
    webxr="optionalFeatures: hit-test,dom-overlay,anchors; overlayElement: #overlay"
    xr-mode-ui="enabled: true"
    embedded>

    <a-assets>
      <!-- Use existing asset to avoid load failure; switch back to V2 once the file exists -->
      <a-asset-item id="model" src="./models/7579_3K_V1.glb"></a-asset-item>
    </a-assets>

    <!-- Reticle -->
    <a-entity id="reticle" visible="false"
      geometry="primitive: ring; radiusInner: 0.07; radiusOuter: 0.08"
      material="color: #00FFAA; shader: flat; opacity: 0.9"
      rotation="-90 0 0"></a-entity>

    <!-- Model to place (scale 1) -->
    <a-entity id="worldModel" gltf-model="#model" scale="1 1 1" visible="false"></a-entity>

    <!-- Basic lights so GLTF/placeholder are visible -->
    <a-entity light="type: ambient; intensity: 1"></a-entity>
    <a-entity light="type: directional; intensity: 0.8" position="0 1 0"></a-entity>

    <a-entity camera></a-entity>
  </a-scene>

  <script>
    (function() {
      // Bump this number before each commit to verify latest deployed build
      const BUILD_NUMBER = 3; // INCREMENT BEFORE COMMIT
      console.log(`[Build] webxr.html build`, BUILD_NUMBER);
      const badgeEl = document.getElementById('buildBadge');
      if (badgeEl) badgeEl.textContent = `build ${BUILD_NUMBER}`;
      const url = new URL(window.location.href);
      const safeMode = url.searchParams.get('safemode') === '1' || url.searchParams.get('safe') === '1';
      const forceBasic = url.searchParams.get('forceBasic') === '1';
      const sceneEl = document.querySelector('a-scene');
      const reticleEl = document.getElementById('reticle');
      const modelEl = document.getElementById('worldModel');
      // Log when the GLB finishes loading and optionally force basic materials for visibility
      modelEl.addEventListener('model-loaded', (e) => {
        console.log('[Model] GLB loaded', e?.detail);
        if (forceBasic && modelEl.object3D) {
          try {
            modelEl.object3D.traverse((child) => {
              if (child.material) {
                const map = child.material.map || null;
                child.material = new THREE.MeshBasicMaterial({ color: 0xffffff, map });
              }
            });
            console.log('[Model] Applied basic materials for visibility');
          } catch(err) { console.warn('Force basic failed', err); }
        }
      });
      const startBtn = document.getElementById('startBtn');
      const copyLogsBtn = document.getElementById('copyLogsBtn');
      const placeBtn = document.getElementById('placeBtn');
      const resetBtn = document.getElementById('resetBtn');
      const hintEl = document.getElementById('hint');
      const backBtn = document.getElementById('backBtn');

      let xrSession = null;
      let hitTestSource = null;
      let viewerSpace = null;
      let refSpace = null;
      let anchor = null; // optional XRAnchor if supported
      let haveHitTest = false;
      // Cache the last valid XR viewer pose (updated inside the XR frame callback)
      let lastViewerPosition = new THREE.Vector3();
      let lastViewerOrientation = new THREE.Quaternion();
      let haveViewerPose = false;

      function supportsWebXR() {
        return navigator.xr && navigator.xr.isSessionSupported;
      }

      let starting = false;
      async function startAR() {
        // Toggle behavior: if a session exists, end it first
        if (xrSession) {
          try { await xrSession.end(); } catch (_) {}
          return;
        }
        if (starting) return; starting = true;
        if (!supportsWebXR()) {
          alert('WebXR AR not supported on this device/browser. Try Chrome/Android or Safari iOS 17+.');
          starting = false; return;
        }
        const supported = await navigator.xr.isSessionSupported('immersive-ar');
        if (!supported) {
          alert('Immersive AR session not supported.');
          starting = false; return;
        }
        console.log('[WebXR] Requesting AR session via navigator.xr.requestSession...');
        try {
          const overlay = document.getElementById('overlay');
          const required = ['hit-test'];
          // Request local-floor if available
          required.push('local-floor');
          const optional = ['anchors'];
          if (!safeMode) {
            optional.push('dom-overlay');
          }
          const sessionInit = {
            requiredFeatures: required,
            optionalFeatures: optional,
            domOverlay: safeMode ? undefined : { root: overlay }
          };
          console.log('[WebXR] sessionInit', sessionInit);
          const session = await navigator.xr.requestSession('immersive-ar', sessionInit);
          sceneEl.renderer.xr.setSession(session);
          if (startBtn) startBtn.textContent = 'Exit AR';
          // Ensure transparent background in AR
          if (sceneEl.renderer && sceneEl.renderer.setClearColor) {
            sceneEl.renderer.setClearColor(0x000000, 0);
          }
          // Ensure in-page console is visible once AR starts
          if (window.eruda && typeof eruda.show === 'function') { try { eruda.show(); } catch(e){} }
          hintEl.textContent = 'AR session started. Move to find a surface.';
          // Proactively run AR init in case framework event doesn't fire
          try { await onEnterVR(); } catch (err) { console.warn('AR init fallback failed', err); }
        } catch (e) {
          console.error('[WebXR] requestSession failed', e);
          hintEl.textContent = 'Could not start AR session. Ensure camera permission is allowed. Use Back to return to marker mode.';
          starting = false; return;
        }
        // If A-Frame does not dispatch enter-vr automatically, do minimal init
        setTimeout(() => {
          if (!sceneEl.renderer || !sceneEl.renderer.xr || !sceneEl.renderer.xr.getSession()) {
            hintEl.textContent = 'AR session not active. Try again or use Back to return to marker mode.';
            starting = false;
          }
        }, 1500);
      }

      async function onEnterVR() {
        // Called when AR session starts
        xrSession = sceneEl.renderer.xr.getSession();
        refSpace = sceneEl.renderer.xr.getReferenceSpace();
        if (!refSpace && xrSession) {
          try {
            refSpace = await xrSession.requestReferenceSpace('local-floor');
          } catch (e1) {
            try {
              refSpace = await xrSession.requestReferenceSpace('local');
            } catch (e2) {
              console.warn('Could not obtain reference space', e1, e2);
            }
          }
        }

        try {
          viewerSpace = await xrSession.requestReferenceSpace('viewer');
          const hitSource = await xrSession.requestHitTestSource({ space: viewerSpace });
          hitTestSource = hitSource;
          haveHitTest = true;
          placeBtn.disabled = false;
          resetBtn.disabled = false;
          console.log('[WebXR] Hit-test ready. Buttons enabled.');
          hintEl.textContent = 'Move to find a surface, then tap Place.';
        } catch (e) {
          console.warn('Hit-test not available', e);
          haveHitTest = false;
          placeBtn.disabled = false; // Allow fallback placement
          resetBtn.disabled = false;
          hintEl.textContent = 'Hit-test unavailable. Tap Place to drop model 2m ahead.';
        }

        xrSession.addEventListener('end', onSessionEnd);
      }

      function onSessionEnd() {
        xrSession = null;
        hitTestSource = null;
        viewerSpace = null;
        refSpace = null;
        anchor = null;
        reticleEl.setAttribute('visible', false);
        placeBtn.disabled = true;
        resetBtn.disabled = true;
        hintEl.textContent = 'AR session ended. Tap Start AR to try again or go back to marker mode.';
        if (startBtn) startBtn.textContent = 'Start AR';
      }

      // Update reticle each frame
      sceneEl.addEventListener('renderstart', () => {
        // Keep renderer alpha 0 during AR so the camera feed is visible
        if (sceneEl.renderer && sceneEl.renderer.setClearColor) {
          sceneEl.renderer.setClearColor(0x000000, 0);
        }
        sceneEl.renderer.setAnimationLoop((timestamp, frame) => {
          sceneEl.frame = frame;
          if (!frame || !hitTestSource || !refSpace) { reticleEl.setAttribute('visible', false); return; }
          // Update cached viewer pose for use outside this callback
          try {
            const vp = frame.getViewerPose(refSpace);
            if (vp && vp.views && vp.views[0]) {
              const t = vp.transform;
              lastViewerPosition.set(t.position.x, t.position.y, t.position.z);
              lastViewerOrientation.set(t.orientation.x, t.orientation.y, t.orientation.z, t.orientation.w);
              haveViewerPose = true;
            }
          } catch (err) {
            // ignore; will fallback to camera
          }
          const results = frame.getHitTestResults(hitTestSource);
          if (results && results.length > 0) {
            const pose = results[0].getPose(refSpace);
            if (pose) {
              const mat = new THREE.Matrix4();
              mat.fromArray(pose.transform.matrix);
              const o3d = reticleEl.object3D;
              o3d.matrix.copy(mat);
              o3d.matrix.decompose(o3d.position, o3d.quaternion, o3d.scale);
              reticleEl.setAttribute('visible', true);
            }
          } else {
            reticleEl.setAttribute('visible', false);
          }
        });
      });

      async function placeAtReticle() {
        console.log('[Place] begin. reticleVisible=', reticleEl.getAttribute('visible'), 'haveHitTest=', haveHitTest);
        const m = modelEl.object3D;
        if (haveHitTest && reticleEl.getAttribute('visible')) {
          const r = reticleEl.object3D;
          m.position.copy(r.position);
          m.quaternion.copy(r.quaternion);
          console.log('[Place] Using reticle pose', m.position);
        } else {
          // Fallback: place ~2m in front of last known viewer pose, else camera
          if (haveViewerPose) {
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(lastViewerOrientation).normalize();
            const pos = new THREE.Vector3().copy(lastViewerPosition).add(forward.multiplyScalar(2));
            m.position.copy(pos);
            m.quaternion.copy(lastViewerOrientation);
            console.log('[Place] Using cached viewer pose', m.position);
          } else {
            const cam = sceneEl.camera;
            if (!cam) { console.warn('[Place] No viewer pose and no camera'); return; }
            const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(cam.quaternion);
            const pos = new THREE.Vector3().copy(cam.position).add(dir.multiplyScalar(2));
            m.position.copy(pos);
            m.quaternion.copy(cam.quaternion);
            console.log('[Place] Using camera fallback', m.position);
          }
        }
        modelEl.setAttribute('visible', true);
        // Sync A-Frame attributes so transforms persist
        try {
          const euler = new THREE.Euler().setFromQuaternion(m.quaternion, 'YXZ');
          const rot = {
            x: THREE.MathUtils.radToDeg(euler.x),
            y: THREE.MathUtils.radToDeg(euler.y),
            z: THREE.MathUtils.radToDeg(euler.z)
          };
          modelEl.setAttribute('position', `${m.position.x} ${m.position.y} ${m.position.z}`);
          modelEl.setAttribute('rotation', `${rot.x} ${rot.y} ${rot.z}`);
        } catch (_) {}
        // Auto-rescale model to a reasonable size
        try {
          const bbox = new THREE.Box3().setFromObject(m);
          const size = new THREE.Vector3(); bbox.getSize(size);
          const maxDim = Math.max(size.x, size.y, size.z);
          if (Number.isFinite(maxDim) && maxDim > 0) {
            const target = 0.6; // meters
            let factor = target / maxDim;
            factor = Math.min(Math.max(factor, 0.05), 5);
            const curScale = modelEl.getAttribute('scale') || {x:1,y:1,z:1};
            const newScale = `${curScale.x * factor} ${curScale.y * factor} ${curScale.z * factor}`;
            modelEl.setAttribute('scale', newScale);
            console.log('[Place] Rescaled model factor=', factor, 'newScale=', newScale, 'bbox=', size);
          }
        } catch (e) { console.warn('Rescale failed', e); }
        m.updateMatrixWorld(true);
        console.log('[Place] visible=', modelEl.getAttribute('visible'), 'children=', m.children?.length, 'pos=', m.position);
      }

      function resetPlacement() {
        modelEl.setAttribute('visible', false);
        anchor = null;
      }

      // Add logs to verify UI is interactive
      startBtn.addEventListener('click', () => { console.log('[UI] Start AR clicked'); startAR(); });
      if (copyLogsBtn) {
        copyLogsBtn.addEventListener('click', async () => {
          console.log('[UI] Copy logs');
          const text = (window.__logBuffer || []).join('\n');
          const doDownload = () => {
            try {
              const blob = new Blob([text], { type: 'text/plain' });
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url; a.download = 'webxr-logs.txt';
              document.body.appendChild(a); a.click(); document.body.removeChild(a);
              setTimeout(() => URL.revokeObjectURL(url), 1000);
              hintEl.textContent = 'Logs download started.';
            } catch (_) { hintEl.textContent = 'Copy/download failed.'; }
          };
          try {
            await navigator.clipboard.writeText(text);
            hintEl.textContent = 'Logs copied to clipboard.';
          } catch (e) {
            doDownload();
          }
        });
      }
      placeBtn.addEventListener('click', () => { console.log('[UI] Place clicked'); placeAtReticle(); });
      resetBtn.addEventListener('click', () => { console.log('[UI] Reset clicked'); resetPlacement(); });

      sceneEl.addEventListener('enter-vr', onEnterVR);
      sceneEl.addEventListener('exit-vr', onSessionEnd);

      // Ensure overlay receives clicks while in AR (dom-overlay feature)
      document.addEventListener('click', (e) => {
        // no-op, just ensures DOM overlay is interactive
      });

      // If the GLB fails to load, fallback to a visible placeholder so placement works
      modelEl.addEventListener('model-error', (e) => {
        console.error('[Model] Failed to load GLB. Falling back to placeholder.', e?.detail);
        modelEl.removeAttribute('gltf-model');
        modelEl.setAttribute('geometry', 'primitive: box; width: 0.6; height: 0.6; depth: 0.6');
        modelEl.setAttribute('material', 'color: #4ecdc4; metalness: 0.1; roughness: 0.8; shader: flat');
      }, { once: true });

      // Also, if user taps Place and there is no mesh yet, attach a placeholder
      function ensurePlaceholderIfEmpty() {
        const hasChildren = modelEl.object3D && modelEl.object3D.children && modelEl.object3D.children.length > 0;
        if (!hasChildren) {
          modelEl.removeAttribute('gltf-model');
          modelEl.setAttribute('geometry', 'primitive: box; width: 0.6; height: 0.6; depth: 0.6');
          modelEl.setAttribute('material', 'color: #4ecdc4; metalness: 0.1; roughness: 0.8; shader: flat');
        }
      }

      const __originalPlace = placeAtReticle;
      placeAtReticle = async function() {
        ensurePlaceholderIfEmpty();
        // Show a brief debug marker where we intend to place
        try { const pos = modelEl.object3D.position; showDebugMarkerAt(pos); } catch(_){}
        return __originalPlace.apply(this, arguments);
      };

      function showDebugMarkerAt(positionVec3) {
        try {
          let marker = document.getElementById('debugMarker');
          if (!marker) {
            marker = document.createElement('a-entity');
            marker.setAttribute('id', 'debugMarker');
            marker.setAttribute('geometry', 'primitive: sphere; radius: 0.05');
            marker.setAttribute('material', 'color: #ffcc00; shader: flat; opacity: 0.9');
            document.querySelector('a-scene').appendChild(marker);
          }
          marker.setAttribute('position', `${positionVec3.x} ${positionVec3.y} ${positionVec3.z}`);
          marker.setAttribute('visible', true);
          setTimeout(() => { const m = document.getElementById('debugMarker'); if (m) m.setAttribute('visible', false); }, 1500);
        } catch (_) {}
      }
    })();
  </script>

  <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
  <script>
    eruda.init();
  </script>

</body>
</html>


